{"version":3,"file":"211.render-page.js","mappings":";;;;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA,qBAAqB,qBAAqB;AAC1C;AACA,WAAW,8BAA8B;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD;AAChD,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,sCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yGAAyG;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;;AAGA;AACA,oCAAoC;;AAEpC;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;;;AAG1D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA,KAAK;;;AAGL;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,uCAAuC;AACpD,WAAW,6BAA6B;AACxC,WAAW,SAAS;AACpB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,2BAA2B;AACtC,aAAa,eAAe;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,YAAY;AACZ,aAAa;AACb,cAAc;AACd,cAAc;AACd,cAAc;AACd,aAAa;AACb;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH,uCAAuC;AACvC;;AAEA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,GAAG;AACzB,2DAA2D;AAC3D;;AAEA;AACA,gCAAgC;AAChC;;AAEA,yEAAyE,GAAG;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,uBAAuB;AACpC,aAAa,sBAAsB;AACnC,aAAa,SAAS;AACtB,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kDAAkD;AACnE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;;AAEA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kDAAkD;AACnE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,GAAG,GAAG,GAAG;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,qDAAqD,GAAG;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,iFAAiF;AACjF;;AAEA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA,wCAAwC,gBAAgB,UAAU;;AAElE;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,oDAAoD;;AAEpD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,4FAA4F;AAC5F;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB;AACtB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,GAAG;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,GAAG;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;;AAEA,sBAAsB,gBAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;;AAEnB,qDAAqD;;AAErD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,2DAA2D;;AAE3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEqC;AACrC;;;;;;;;;;;;;;;ACnoDY;AACsC;AACa;AACL;AAC1D;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA,kBAAkB,iHAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6CAA6C;AACnF;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,iHAAgC;AAClD;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB,kCAAkC;AAC1D,MAAM;AACN,oBAAoB,kCAAkC;AACtD,MAAM;AACN,mBAAmB,kCAAkC;AACrD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,EAAE,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN,EAAE,yDAAQ;AACV;AACA;AACA;AACA;AACA,aAAa,0DAAc;AAC3B;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,gDAAgD,mCAAmC,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AAGE;AACF","sources":["webpack://bradkim06/./node_modules/@khanacademy/simple-markdown/dist/es/index.js","webpack://bradkim06/./node_modules/mermaid/dist/createText-1f5f8f92.js"],"sourcesContent":["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n// Flow Type Definitions:\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\n// End Flow Definitions\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\n\nvar preprocess = function preprocess(source) {\n  return source.replace(CR_NEWLINE_R, \"\\n\").replace(FORMFEED_R, \"\").replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function populateInitialState(givenState, defaultState) {\n  var state = givenState || {};\n\n  if (defaultState != null) {\n    for (var prop in defaultState) {\n      // $FlowFixMe\n      if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n        state[prop] = defaultState[prop];\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\n\n\nvar parserFor = function parserFor(rules, defaultState) {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  var ruleList = Object.keys(rules).filter(function (type) {\n    var rule = rules[type];\n\n    if (rule == null || rule.match == null) {\n      return false;\n    }\n\n    var order = rule.order;\n\n    if ((typeof order !== \"number\" || !isFinite(order)) && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n    }\n\n    return true;\n  });\n  ruleList.sort(function (typeA, typeB) {\n    var ruleA = rules[typeA];\n    var ruleB = rules[typeB];\n    var orderA = ruleA.order;\n    var orderB = ruleB.order; // First sort based on increasing order\n\n    if (orderA !== orderB) {\n      return orderA - orderB;\n    }\n\n    var secondaryOrderA = ruleA.quality ? 0 : 1;\n    var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n    if (secondaryOrderA !== secondaryOrderB) {\n      return secondaryOrderA - secondaryOrderB; // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1;\n    } else if (typeA > typeB) {\n      return 1;\n    } else {\n      // Rules should never have the same name,\n      // but this is provided for completeness.\n      return 0;\n    }\n  });\n  var latestState;\n\n  var nestedParse = function nestedParse(source, state) {\n    var result = [];\n    state = state || latestState;\n    latestState = state;\n\n    while (source) {\n      // store the best match, it's rule, and quality:\n      var ruleType = null;\n      var rule = null;\n      var capture = null;\n      var quality = NaN; // loop control variables:\n\n      var i = 0;\n      var currRuleType = ruleList[0]; // $FlowFixMe\n\n      var currRule = rules[currRuleType];\n\n      do {\n        var currOrder = currRule.order;\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var currCapture = currRule.match(source, state, prevCaptureStr);\n\n        if (currCapture) {\n          var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0; // This should always be true the first time because\n          // the initial quality is NaN (that's why there's the\n          // condition negation).\n\n          if (!(currQuality <= quality)) {\n            ruleType = currRuleType;\n            rule = currRule;\n            capture = currCapture;\n            quality = currQuality;\n          }\n        } // Move on to the next item.\n        // Note that this makes `currRule` be the next item\n\n\n        i++;\n        currRuleType = ruleList[i]; // $FlowFixMe\n\n        currRule = rules[currRuleType];\n      } while ( // keep looping while we're still within the ruleList\n      currRule && ( // if we don't have a match yet, continue\n      !capture || // or if we have a match, but the next rule is\n      // at the same order, and has a quality measurement\n      // functions, then this rule must have a quality\n      // measurement function (since they are sorted before\n      // those without), and we need to check if there is\n      // a better quality match\n      currRule.order === currOrder && currRule.quality)); // TODO(aria): Write tests for these\n\n\n      if (rule == null || capture == null) {\n        throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n      }\n\n      if (capture.index) {\n        // If present and non-zero, i.e. a non-^ regexp result:\n        throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n      }\n\n      var parsed = rule.parse(capture, nestedParse, state); // We maintain the same object here so that rules can\n      // store references to the objects they return and\n      // modify them later. (oops sorry! but this adds a lot\n      // of power--see reflinks.)\n\n      if (Array.isArray(parsed)) {\n        // $FlowFixMe\n        Array.prototype.push.apply(result, parsed);\n      } else {\n        if (parsed == null || typeof parsed !== \"object\") {\n          throw new Error(\"parse() function returned invalid parse result: '\".concat(parsed, \"'\"));\n        } // We also let rules override the default type of\n        // their parsed node if they would like to, so that\n        // there can be a single output function for all links,\n        // even if there are several rules to parse them.\n\n\n        if (parsed.type == null) {\n          // $FlowFixMe\n          parsed.type = ruleType;\n        }\n\n        result.push(parsed);\n      }\n\n      state.prevCapture = capture;\n      source = source.substring(state.prevCapture[0].length);\n    } // $FlowFixMe\n\n\n    return result;\n  };\n\n  var outerParse = function outerParse(source, state) {\n    latestState = populateInitialState(state, defaultState);\n\n    if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n      source = source + \"\\n\\n\";\n    } // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information). This stores\n    // the full regex capture object, if there is one.\n\n\n    latestState.prevCapture = null;\n    return nestedParse(preprocess(source), latestState);\n  }; // $FlowFixMe\n\n\n  return outerParse;\n}; // Creates a match function for an inline scoped element from a regex\n\n\nvar inlineRegex = function inlineRegex(regex) {\n  var match = function match(source, state, prevCapture) {\n    if (state.inline) {\n      // $FlowFixMe\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function for a block scoped element from a regex\n\n\nvar blockRegex = function blockRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    if (state.inline) {\n      return null;\n    } else {\n      return regex.exec(source);\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function from a regex, ignoring block/inline scope\n\n\nvar anyScopeRegex = function anyScopeRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    return regex.exec(source);\n  };\n\n  match.regex = regex;\n  return match;\n};\n\nvar TYPE_SYMBOL = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n\nvar reactElement = function reactElement(type, key, props) {\n  var element = {\n    $$typeof: TYPE_SYMBOL,\n    type: type,\n    key: key == null ? undefined : key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n  return element;\n};\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\n\n\nvar htmlTag = function htmlTag(tagName, content, attributes, isClosed) {\n  attributes = attributes || {};\n  isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n  var attributeString = \"\";\n\n  for (var attr in attributes) {\n    var attribute = attributes[attr]; // Removes falsey attributes\n\n    if ( // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n      attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n    }\n  }\n\n  var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n  if (isClosed) {\n    return unclosedTag + content + \"</\" + tagName + \">\";\n  } else {\n    return unclosedTag;\n  }\n};\n\nvar EMPTY_PROPS = {};\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\n\nvar sanitizeUrl = function sanitizeUrl(url) {\n  if (url == null) {\n    return null;\n  }\n\n  try {\n    var prot = new URL(url, \"https://localhost\").protocol;\n\n    if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n      return null;\n    }\n  } catch (e) {\n    // invalid URLs should throw a TypeError\n    // see for instance: `new URL(\"\");`\n    return null;\n  }\n\n  return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"&\": \"&amp;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#96;\"\n};\n\nvar sanitizeText = function sanitizeText(text) {\n  return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n    return SANITIZE_TEXT_CODES[chr];\n  });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function unescapeUrl(rawUrlString) {\n  return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\n\n\nvar parseInline = function parseInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseBlock = function parseBlock(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = false;\n  var result = parse(content + \"\\n\\n\", state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n  return {\n    content: parseInline(parse, capture[1], state)\n  };\n};\n\nvar ignoreCapture = function ignoreCapture() {\n  return {};\n}; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\n\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\"; // recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\n\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX); // recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\n\nvar LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g; // recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\n\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/; // check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\n\nvar LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" + // the \\\\s*$ here is so that we can parse the inside of nested\n// lists, where our content might end before we receive two `\\n`s\n\"|\\\\s*\\n*$)\");\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = function () {\n  var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n  var TABLE_CELL_END_TRIM = / *$/;\n  var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n  var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n  var TABLE_LEFT_ALIGN = /^ *:-+ *$/; // TODO: This needs a real type\n\n  var parseTableAlignCapture = function parseTableAlignCapture(alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n      return \"right\";\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n      return \"center\";\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n      return \"left\";\n    } else {\n      return null;\n    }\n  };\n\n  var parseTableAlign = function parseTableAlign(source, parse, state, trimEndSeparators) {\n    if (trimEndSeparators) {\n      source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n    }\n\n    var alignText = source.trim().split(\"|\");\n    return alignText.map(parseTableAlignCapture);\n  };\n\n  var parseTableRow = function parseTableRow(source, parse, state, trimEndSeparators) {\n    var prevInTable = state.inTable;\n    state.inTable = true;\n    var tableRow = parse(source.trim(), state);\n    state.inTable = prevInTable;\n    var cells = [[]];\n    tableRow.forEach(function (node, i) {\n      if (node.type === \"tableSeparator\") {\n        // Filter out empty table separators at the start/end:\n        if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n          // Split the current row:\n          cells.push([]);\n        }\n      } else {\n        if (node.type === \"text\" && (tableRow[i + 1] == null || tableRow[i + 1].type === \"tableSeparator\")) {\n          node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n        }\n\n        cells[cells.length - 1].push(node);\n      }\n    });\n    return cells;\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.ASTNode[][]}\n   */\n\n\n  var parseTableCells = function parseTableCells(source, parse, state, trimEndSeparators) {\n    var rowsText = source.trim().split(\"\\n\");\n    return rowsText.map(function (rowText) {\n      // $FlowFixMe\n      return parseTableRow(rowText, parse, state, trimEndSeparators);\n    });\n  };\n  /**\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.SingleNodeParseFunction}\n   */\n\n\n  var parseTable = function parseTable(trimEndSeparators) {\n    return function (capture, parse, state) {\n      state.inline = true;\n      var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n      var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n      var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n      state.inline = false;\n      return {\n        type: \"table\",\n        header: header,\n        align: align,\n        cells: cells\n      };\n    };\n  };\n\n  return {\n    parseTable: parseTable(true),\n    parseNpTable: parseTable(false),\n    TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n    NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n  };\n}();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function parseRef(capture, state, refNode) {\n  var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase(); // We store information about previously seen defs on\n  // state._defs (_ to deconflict with client-defined\n  // state). If the def for this reflink/refimage has\n  // already been seen, we can use its target/source\n  // and title here:\n\n  if (state._defs && state._defs[ref]) {\n    var def = state._defs[ref]; // `refNode` can be a link or an image. Both use\n    // target and title properties.\n\n    refNode.target = def.target;\n    refNode.title = def.title;\n  } // In case we haven't seen our def yet (or if someone\n  // overwrites that def later on), we add this node\n  // to the list of ref nodes for that def. Then, when\n  // we find the def, we can modify this link/image AST\n  // node :).\n  // I'm sorry.\n\n\n  state._refs = state._refs || {};\n  state._refs[ref] = state._refs[ref] || [];\n\n  state._refs[ref].push(refNode);\n\n  return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules = {\n  Array: {\n    react: function react(arr, output, state) {\n      var oldKey = state.key;\n      var result = []; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0, key = 0; i < arr.length; i++, key++) {\n        // `key` is our numerical `state.key`, which we increment for\n        // every output node, but don't change for joined text nodes.\n        // (i, however, must change for joined text nodes)\n        state.key = \"\" + i;\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result.push(output(node, state));\n      }\n\n      state.key = oldKey;\n      return result;\n    },\n    html: function html(arr, output, state) {\n      var result = \"\"; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0; i < arr.length; i++) {\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result += output(node, state);\n      }\n\n      return result;\n    }\n  },\n  heading: {\n    order: currOrder++,\n    match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n    parse: function (_parse) {\n      function parse(_x, _x2, _x3) {\n        return _parse.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        level: capture[1].length,\n        content: parseInline(parse, capture[2].trim(), state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"h\" + node.level, state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"h\" + node.level, output(node.content, state));\n    }\n  },\n  nptable: {\n    order: currOrder++,\n    match: blockRegex(TABLES.NPTABLE_REGEX),\n    parse: TABLES.parseNpTable,\n    react: null,\n    html: null\n  },\n  lheading: {\n    order: currOrder++,\n    match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n    parse: function (_parse2) {\n      function parse(_x4, _x5, _x6) {\n        return _parse2.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse2.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"heading\",\n        level: capture[2] === \"=\" ? 1 : 2,\n        content: parseInline(parse, capture[1], state)\n      };\n    }),\n    react: null,\n    html: null\n  },\n  hr: {\n    order: currOrder++,\n    match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"hr\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<hr>\";\n    }\n  },\n  codeBlock: {\n    order: currOrder++,\n    match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n    parse: function (_parse3) {\n      function parse(_x7, _x8, _x9) {\n        return _parse3.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse3.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n      return {\n        lang: undefined,\n        content: content\n      };\n    }),\n    react: function react(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      return reactElement(\"pre\", state.key, {\n        children: reactElement(\"code\", null, {\n          className: className,\n          children: node.content\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n        class: className\n      });\n      return htmlTag(\"pre\", codeBlock);\n    }\n  },\n  fence: {\n    order: currOrder++,\n    match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n    parse: function (_parse4) {\n      function parse(_x10, _x11, _x12) {\n        return _parse4.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse4.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"codeBlock\",\n        lang: capture[2] || undefined,\n        content: capture[3]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  blockQuote: {\n    order: currOrder++,\n    match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n    parse: function (_parse5) {\n      function parse(_x13, _x14, _x15) {\n        return _parse5.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse5.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^ *> ?/gm, \"\");\n      return {\n        content: parse(content, state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"blockquote\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"blockquote\", output(node.content, state));\n    }\n  },\n  list: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      // We only want to break into a list if we are at the start of a\n      // line. This is to avoid parsing \"hi * there\" with \"* there\"\n      // becoming a part of a list.\n      // You might wonder, \"but that's inline, so of course it wouldn't\n      // start a list?\". You would be correct! Except that some of our\n      // lists can be inline, because they might be inside another list,\n      // in which case we can parse with inline scope, but need to allow\n      // nested lists inside this inline scope.\n      var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n      var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n      var isListBlock = state._list || !state.inline;\n\n      if (isStartOfLineCapture && isListBlock) {\n        source = isStartOfLineCapture[1] + source;\n        return LIST_R.exec(source);\n      } else {\n        return null;\n      }\n    },\n    parse: function (_parse6) {\n      function parse(_x16, _x17, _x18) {\n        return _parse6.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse6.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var bullet = capture[2];\n      var ordered = bullet.length > 1;\n      var start = ordered ? +bullet : undefined;\n      var items = capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R); // We know this will match here, because of how the regexes are\n      // defined\n\n      var lastItemWasAParagraph = false;\n      var itemContent = items.map(function (item, i) {\n        // We need to see how far indented this item is:\n        var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n        var space = prefixCapture ? prefixCapture[0].length : 0; // And then we construct a regex to \"unindent\" the subsequent\n        // lines of the items by that amount:\n\n        var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\"); // Before processing the item, we need a couple things\n\n        var content = item // remove indents on trailing lines:\n        .replace(spaceRegex, \"\") // remove the bullet:\n        .replace(LIST_ITEM_PREFIX_R, \"\"); // I'm not sur4 why this is necessary again?\n        // Handling \"loose\" lists, like:\n        //\n        //  * this is wrapped in a paragraph\n        //\n        //  * as is this\n        //\n        //  * as is this\n\n        var isLastItem = i === items.length - 1;\n        var containsBlocks = content.indexOf(\"\\n\\n\") !== -1; // Any element in a list is a block if it contains multiple\n        // newlines. The last element in the list can also be a block\n        // if the previous item in the list was a block (this is\n        // because non-last items in the list can end with \\n\\n, but\n        // the last item can't, so we just \"inherit\" this property\n        // from our previous element).\n\n        var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n        lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n        // want to set state._list to true, and state.inline depending\n        // on our list's looseness.\n\n        var oldStateInline = state.inline;\n        var oldStateList = state._list;\n        state._list = true; // Parse inline if we're in a tight list, or block if we're in\n        // a loose list.\n\n        var adjustedContent;\n\n        if (thisItemIsAParagraph) {\n          state.inline = false;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n        } else {\n          state.inline = true;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n        }\n\n        var result = parse(adjustedContent, state); // Restore our state before returning\n\n        state.inline = oldStateInline;\n        state._list = oldStateList;\n        return result;\n      });\n      return {\n        ordered: ordered,\n        start: start,\n        items: itemContent\n      };\n    }),\n    react: function react(node, output, state) {\n      var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n      return reactElement(ListWrapper, state.key, {\n        start: node.start,\n        children: node.items.map(function (item, i) {\n          return reactElement(\"li\", \"\" + i, {\n            children: output(item, state)\n          });\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var listItems = node.items.map(function (item) {\n        return htmlTag(\"li\", output(item, state));\n      }).join(\"\");\n      var listTag = node.ordered ? \"ol\" : \"ul\";\n      var attributes = {\n        start: node.start\n      };\n      return htmlTag(listTag, listItems, attributes);\n    }\n  },\n  def: {\n    order: currOrder++,\n    // TODO(aria): This will match without a blank line before the next\n    // block element, which is inconsistent with most of the rest of\n    // simple-markdown.\n    match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n    parse: function (_parse7) {\n      function parse(_x19, _x20, _x21) {\n        return _parse7.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse7.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n      var target = capture[2];\n      var title = capture[3]; // Look for previous links/images using this def\n      // If any links/images using this def have already been declared,\n      // they will have added themselves to the state._refs[def] list\n      // (_ to deconflict with client-defined state). We look through\n      // that list of reflinks for this def, and modify those AST nodes\n      // with our newly found information now.\n      // Sorry :(.\n\n      if (state._refs && state._refs[def]) {\n        // `refNode` can be a link or an image\n        state._refs[def].forEach(function (refNode) {\n          refNode.target = target;\n          refNode.title = title;\n        });\n      } // Add this def to our map of defs for any future links/images\n      // In case we haven't found any or all of the refs referring to\n      // this def yet, we add our def to the table of known defs, so\n      // that future reflinks can modify themselves appropriately with\n      // this information.\n\n\n      state._defs = state._defs || {};\n      state._defs[def] = {\n        target: target,\n        title: title\n      }; // return the relevant parsed information\n      // for debugging only.\n\n      return {\n        def: def,\n        target: target,\n        title: title\n      };\n    }),\n    react: function react() {\n      return null;\n    },\n    html: function html() {\n      return \"\";\n    }\n  },\n  table: {\n    order: currOrder++,\n    match: blockRegex(TABLES.TABLE_REGEX),\n    parse: TABLES.parseTable,\n    react: function react(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? {} : {\n          textAlign: node.align[colIndex]\n        };\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return reactElement(\"th\", \"\" + i, {\n          style: getStyle(i),\n          scope: \"col\",\n          children: output(content, state)\n        });\n      });\n      var rows = node.cells.map(function (row, r) {\n        return reactElement(\"tr\", \"\" + r, {\n          children: row.map(function (content, c) {\n            return reactElement(\"td\", \"\" + c, {\n              style: getStyle(c),\n              children: output(content, state)\n            });\n          })\n        });\n      });\n      return reactElement(\"table\", state.key, {\n        children: [reactElement(\"thead\", \"thead\", {\n          children: reactElement(\"tr\", null, {\n            children: headers\n          })\n        }), reactElement(\"tbody\", \"tbody\", {\n          children: rows\n        })]\n      });\n    },\n    html: function html(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return htmlTag(\"th\", output(content, state), {\n          style: getStyle(i),\n          scope: \"col\"\n        });\n      }).join(\"\");\n      var rows = node.cells.map(function (row) {\n        var cols = row.map(function (content, c) {\n          return htmlTag(\"td\", output(content, state), {\n            style: getStyle(c)\n          });\n        }).join(\"\");\n        return htmlTag(\"tr\", cols);\n      }).join(\"\");\n      var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n      var tbody = htmlTag(\"tbody\", rows);\n      return htmlTag(\"table\", thead + tbody);\n    }\n  },\n  newline: {\n    order: currOrder++,\n    match: blockRegex(/^(?:\\n *)*\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return \"\\n\";\n    },\n    html: function html(node, output, state) {\n      return \"\\n\";\n    }\n  },\n  paragraph: {\n    order: currOrder++,\n    match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"div\", state.key, {\n        className: \"paragraph\",\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        class: \"paragraph\"\n      };\n      return htmlTag(\"div\", output(node.content, state), attributes);\n    }\n  },\n  escape: {\n    order: currOrder++,\n    // We don't allow escaping numbers, letters, or spaces here so that\n    // backslashes used in plain text still get rendered. But allowing\n    // escaping anything else provides a very flexible escape mechanism,\n    // regardless of how this grammar is extended.\n    match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n    parse: function (_parse8) {\n      function parse(_x22, _x23, _x24) {\n        return _parse8.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse8.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"text\",\n        content: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  tableSeparator: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      if (!state.inTable) {\n        return null;\n      }\n\n      return /^ *\\| */.exec(source);\n    },\n    parse: function parse() {\n      return {\n        type: \"tableSeparator\"\n      };\n    },\n    // These shouldn't be reached, but in case they are, be reasonable:\n    react: function react() {\n      return \" | \";\n    },\n    html: function html() {\n      return \" &vert; \";\n    }\n  },\n  autolink: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n    parse: function (_parse9) {\n      function parse(_x25, _x26, _x27) {\n        return _parse9.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse9.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  mailto: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n    parse: function (_parse10) {\n      function parse(_x28, _x29, _x30) {\n        return _parse10.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse10.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var address = capture[1];\n      var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n      if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n        target = \"mailto:\" + target;\n      }\n\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: address\n        }],\n        target: target\n      };\n    }),\n    react: null,\n    html: null\n  },\n  url: {\n    order: currOrder++,\n    match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n    parse: function (_parse11) {\n      function parse(_x31, _x32, _x33) {\n        return _parse11.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse11.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1],\n        title: undefined\n      };\n    }),\n    react: null,\n    html: null\n  },\n  link: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse12) {\n      function parse(_x34, _x35, _x36) {\n        return _parse12.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse12.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var link = {\n        content: parse(capture[1], state),\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return link;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"a\", state.key, {\n        href: sanitizeUrl(node.target),\n        title: node.title,\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        href: sanitizeUrl(node.target),\n        title: node.title\n      };\n      return htmlTag(\"a\", output(node.content, state), attributes);\n    }\n  },\n  image: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse13) {\n      function parse(_x37, _x38, _x39) {\n        return _parse13.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse13.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var image = {\n        alt: capture[1],\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return image;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"img\", state.key, {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      };\n      return htmlTag(\"img\", \"\", attributes, false);\n    }\n  },\n  reflink: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse14) {\n      function parse(_x40, _x41, _x42) {\n        return _parse14.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse14.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"link\",\n        content: parse(capture[1], state)\n      });\n    }),\n    react: null,\n    html: null\n  },\n  refimage: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse15) {\n      function parse(_x43, _x44, _x45) {\n        return _parse15.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse15.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"image\",\n        alt: capture[1]\n      });\n    }),\n    react: null,\n    html: null\n  },\n  em: {\n    order: currOrder\n    /* same as strong/u */\n    ,\n    match: inlineRegex(new RegExp( // only match _s surrounding words.\n    \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" + // Or match *s:\n    \"|\" + // Only match *s that are followed by a non-space:\n    \"^\\\\*(?=\\\\S)(\" + // Match at least one of:\n    \"(?:\" + //  - `**`: so that bolds inside italics don't close the\n    //          italics\n    \"\\\\*\\\\*|\" + //  - escape sequence: so escaped *s don't close us\n    \"\\\\\\\\[\\\\s\\\\S]|\" + //  - whitespace: followed by a non-* (we don't\n    //          want ' *' to close an italics--it might\n    //          start a list)\n    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" + //  - non-whitespace, non-*, non-backslash characters\n    \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" + // followed by a non-space, non-* then *\n    \")\\\\*(?!\\\\*)\")),\n    quality: function quality(capture) {\n      // precedence by length, `em` wins ties:\n      return capture[0].length + 0.2;\n    },\n    parse: function (_parse16) {\n      function parse(_x46, _x47, _x48) {\n        return _parse16.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse16.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: parse(capture[2] || capture[1], state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"em\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"em\", output(node.content, state));\n    }\n  },\n  strong: {\n    order: currOrder\n    /* same as em */\n    ,\n    match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n    quality: function quality(capture) {\n      // precedence by length, wins ties vs `u`:\n      return capture[0].length + 0.1;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"strong\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"strong\", output(node.content, state));\n    }\n  },\n  u: {\n    order: currOrder++\n    /* same as em&strong; increment for next rule */\n    ,\n    match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n    quality: function quality(capture) {\n      // precedence by length, loses all ties\n      return capture[0].length;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"u\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"u\", output(node.content, state));\n    }\n  },\n  del: {\n    order: currOrder++,\n    match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"del\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"del\", output(node.content, state));\n    }\n  },\n  inlineCode: {\n    order: currOrder++,\n    match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n    parse: function (_parse17) {\n      function parse(_x49, _x50, _x51) {\n        return _parse17.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse17.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"code\", state.key, {\n        children: node.content\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"code\", sanitizeText(node.content));\n    }\n  },\n  br: {\n    order: currOrder++,\n    match: anyScopeRegex(/^ {2,}\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"br\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<br>\";\n    }\n  },\n  text: {\n    order: currOrder++,\n    // Here we look for anything followed by non-symbols,\n    // double newlines, or double-space-newlines\n    // We break on any symbol characters so that this grammar\n    // is easy to extend without needing to modify this regex\n    match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n    parse: function (_parse18) {\n      function parse(_x52, _x53, _x54) {\n        return _parse18.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse18.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[0]\n      };\n    }),\n    react: function react(node, output, state) {\n      return node.content;\n    },\n    html: function html(node, output, state) {\n      return sanitizeText(node.content);\n    }\n  }\n};\n/** (deprecated) */\n\nvar ruleOutput = function ruleOutput( // $FlowFixMe\nrules, property) {\n  if (!property && typeof console !== \"undefined\") {\n    console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n  }\n\n  var nestedRuleOutput = function nestedRuleOutput(ast, outputFunc, state) {\n    return rules[ast.type][property](ast, outputFunc, state);\n  };\n\n  return nestedRuleOutput;\n};\n/** (deprecated)\n */\n\n\nvar reactFor = function reactFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      var oldKey = state.key;\n      var result = []; // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n\n      var lastResult = null;\n\n      for (var i = 0; i < ast.length; i++) {\n        state.key = \"\" + i;\n        var nodeOut = nestedOutput(ast[i], state);\n\n        if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n          lastResult = lastResult + nodeOut;\n          result[result.length - 1] = lastResult;\n        } else {\n          result.push(nodeOut);\n          lastResult = nodeOut;\n        }\n      }\n\n      state.key = oldKey;\n      return result;\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n/** (deprecated)\n */\n\n\nvar htmlFor = function htmlFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      return ast.map(function (node) {\n        return nestedOutput(node, state);\n      }).join(\"\");\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n\nvar outputFor = function outputFor(rules, property) {\n  var defaultState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!property) {\n    throw new Error(\"simple-markdown: outputFor: `property` must be \" + \"defined. \" + \"if you just upgraded, you probably need to replace `outputFor` \" + \"with `reactFor`\");\n  }\n\n  var latestState; // $FlowFixMe[incompatible-type]\n\n  var arrayRule = rules.Array || defaultRules.Array; // Tricks to convince tsc that this var is not null:\n\n  var arrayRuleCheck = arrayRule[property];\n\n  if (!arrayRuleCheck) {\n    throw new Error(\"simple-markdown: outputFor: to join nodes of type `\" + property + \"` you must provide an `Array:` joiner rule with that type, \" + \"Please see the docs for details on specifying an Array rule.\");\n  }\n\n  var arrayRuleOutput = arrayRuleCheck;\n\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || latestState;\n    latestState = state;\n\n    if (Array.isArray(ast)) {\n      return arrayRuleOutput(ast, nestedOutput, state);\n    } else {\n      return rules[ast.type][property](ast, nestedOutput, state);\n    }\n  };\n\n  var outerOutput = function outerOutput(ast, state) {\n    latestState = populateInitialState(state, defaultState);\n    return nestedOutput(ast, latestState);\n  };\n\n  return outerOutput;\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function defaultBlockParse(source, state) {\n  state = state || {};\n  state.inline = false;\n  return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function defaultInlineParse(source, state) {\n  state = state || {};\n  state.inline = true;\n  return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function defaultImplicitParse(source, state) {\n  var isBlock = BLOCK_END_R.test(source);\n  state = state || {};\n  state.inline = !isBlock;\n  return defaultRawParse(source, state);\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultReactOutput = outputFor(defaultRules, \"react\"); // $FlowFixMe[incompatible-call]\n\nvar defaultHtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function markdownToReact(source, state) {\n  return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function markdownToHtml(source, state) {\n  return defaultHtmlOutput(defaultBlockParse(source, state), state);\n}; // TODO: This needs definition\n\n\nvar ReactMarkdown = function ReactMarkdown(props) {\n  var divProps = {};\n\n  for (var prop in props) {\n    if (prop !== \"source\" && // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(props, prop)) {\n      divProps[prop] = props[prop];\n    }\n  }\n\n  divProps.children = markdownToReact(props.source);\n  return reactElement(\"div\", null, divProps);\n};\n\n// $FlowFixMe\nvar SimpleMarkdown = {\n  defaultRules: defaultRules,\n  parserFor: parserFor,\n  outputFor: outputFor,\n  inlineRegex: inlineRegex,\n  blockRegex: blockRegex,\n  anyScopeRegex: anyScopeRegex,\n  parseInline: parseInline,\n  parseBlock: parseBlock,\n  // default wrappers:\n  markdownToReact: markdownToReact,\n  markdownToHtml: markdownToHtml,\n  ReactMarkdown: ReactMarkdown,\n  defaultBlockParse: defaultBlockParse,\n  defaultInlineParse: defaultInlineParse,\n  defaultImplicitParse: defaultImplicitParse,\n  defaultReactOutput: defaultReactOutput,\n  defaultHtmlOutput: defaultHtmlOutput,\n  preprocess: preprocess,\n  sanitizeText: sanitizeText,\n  sanitizeUrl: sanitizeUrl,\n  unescapeUrl: unescapeUrl,\n  htmlTag: htmlTag,\n  reactElement: reactElement,\n  // deprecated:\n  defaultRawParse: defaultRawParse,\n  ruleOutput: ruleOutput,\n  reactFor: reactFor,\n  htmlFor: htmlFor,\n  defaultParse: function defaultParse() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultParse is deprecated, please use `defaultImplicitParse`\");\n    }\n\n    return defaultImplicitParse.apply(null, arguments);\n  },\n  defaultOutput: function defaultOutput() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultOutput is deprecated, please use `defaultReactOutput`\");\n    }\n\n    return defaultReactOutput.apply(null, arguments);\n  }\n};\n\nexport { SimpleMarkdown as default };\n//# sourceMappingURL=index.js.map\n","import \"d3\";\nimport { l as log } from \"./commonDb-573409be.js\";\nimport { d as decodeEntities } from \"./mermaidAPI-3ae0f2f0.js\";\nimport SimpleMarkdown from \"@khanacademy/simple-markdown\";\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, \"\");\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n  let lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType) {\n    if (node.type === \"text\") {\n      const textLines = node.content.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || \"normal\" });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.content.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.content.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.content.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.content.map(output).join(\"\")}</p>`;\n    } else {\n      return \"\";\n    }\n  }\n  return syntaxTree.map(output).join(\"\");\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  let bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n      updateTextContentAndStyles(tspan, wrappedLine);\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n        updateTextContentAndStyles(tspan, wrappedLine);\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width,\n  addSvgBackground = false\n} = {}) => {\n  log.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", \".\", \",\", \":\", \";\", \"!\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\"];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = \"\";\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\nexport {\n  createText as c\n};\n//# sourceMappingURL=createText-1f5f8f92.js.map\n"],"names":[],"sourceRoot":""}