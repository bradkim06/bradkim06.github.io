{"data":{"allMdx":{"edges":[{"node":{"id":"211aa538-896a-5f15-b0af-a9f6e1cccda2","excerpt":"프론트엔드 공부 차원에서 블로그를 2020년에 만들고 꾸준히 글을 쓰려 했으나 2021년들어 사실상 회사의 모든 Firmware…","rawBody":"---\ntitle: 초음파 수도미터\nsubTitle: 초음파 수도미터 오차의 원인과 해결\ncategory: embedded\ndate: 2021-10-10T12:40:18\ncover: ./img/flowmeter.jpg\n---\n\n프론트엔드 공부 차원에서 블로그를 2020년에 만들고 꾸준히 글을 쓰려 했으나 2021년들어 사실상 회사의 모든 Firmware 제품군을 관리하게 되면서 내 코드, 제품의 품질이 만족스럽지가 않았고 하루 종일 그것에만 몰두했다. 사내 제품의 크리티컬한 결함, 개선사항들을 배포하고 다양한 독서와 공부에 시간을 더 투자하고 싶다는 생각이 들어 퇴사를 하고 백수가 된 시점에 남는 시간에 취미삼아 블로그를 하려한다. 이번 포스팅은 신입사원 시절(2018~2019)에 진행한 초음파 수도미터 개발과 관련된 회고이자 복기다.\n\n수도미터 원격 검침 단말 및 시스템을 제조 및 서비스하는 회사에 입사한 첫해에 진행한 초음파 수도미터 개발, 특허출원 과정의 내용과 기억에 남는 문제점, 해결법들을 뒤돌아보며 당시에 내가 결정한 것이 합리적이었는지 곰곰이 생각해보며 글을 쓴다\n\n#### 특허 정보\n\n<a href=\"https://doi.org/10.8080/1020190101926\">초음파 수도 계량기의 유량 측정 방법과 그 초음파 수도계량기\nTHE METHOD OF FLOW MEASUREMENT FOR SONIC FLOW METER, THE SONIC FLOW METER</a>\n\n# 서론\n\n## 개발 배경\n\n회사는 전자식 수도미터 계량기, 수도미터 검침 및 무선(NB-IoT, LoRa) 단말, 검침 데이터를 보여주는\n웹, 서버, 단말기 설정 스마트폰 앱,생산용 PC 앱등 수도미터 원격 검침에 필요한 시스템들을 개발하여 지자체에 납품하는 작은 규모의\n회사였다. 나는 Firmware를 개발하는 신입사원으로 입사하였다.\n\n회사의 기존 전자식 수도미터 계량기 제품은 업계 용어로 임펠러식 혹은 터빈식이라 지칭하였는데 물이 흐르면 내부의 바퀴가 회전하는 방식이다. 업계의 전자식 수도미터는 대부분(90% 이상) 임펠러식을 사용하였다.\n지자체에 납품하여 매출을 올리는데 가격, 보증기간(8년)이 중요한 경쟁요소였고 임펠러식은 가장\n저렴하고 오랜기간 검증된 전자식 수도 계량기였기 때문이다.\n\n회사는 KTC(한국기계전기전자시험연구원)의 차세대 수도미터 개발 협업 요청으로\n초음파 수도미터 개발을 막 시작하려던 참이었고 나는 해당 프로젝트를 입사한지 얼마 안돼 시작하였다.\n\n### 임펠러 수도미터의 이해\n\n초음파 수도미터에 대한 이해에 앞서 기존 임펠러 수도미터를 들여다 볼 필요가\n있다. 차세대 기술, 신제품은 기존의 기술에서 발생하는 단점, 불편함을\n개선, 장점 증대, 새로운 경험의 창출을 이끌어내지 못하면 빛 좋은 개살구가 되기 때문이다.\n\n![turbinFlowMeter](./img/turbinFlowMeter2.jpg)\n\n입사 후 임펠러식에 대한 구조적 이해와 실제 코드를 파악을 하는것 부터\n시작했다. 임펠러 수도미터의 레거시 코드는 10000라인 미만의 작은 코드였고 컨셉이 단순해 파악이 쉬웠다. 임펠러식 수도미터는 그림과 같이 구성된 유량부, 그 위에 결합되는 전자부가\n있다. 유량부는 물이 흐르면 임펠러부가 회전하게 되며 전자부는 임펠러 중앙에\n있는 자석의 회전으로 발생하는 자기장을 센서로 감지하여 회전속도를 알아내고 회전 속도에 따라 유량을 추측식으로 얼마나 흘렀는지 계산을 하게 된다. 여기서 추측식이라고 한 이유는 회전속도를 기반으로 산출한 유량은 마찰, 물의 압력 등 여러가지 요소들로 실제 유량과 같지 않기때문이다\n\n**임펠러 수도미터의 단점**\n\n- 임펠러 회전부와 물의 추가적 마찰로 인해 압력의 손실이 발생\n- 임펠러의 구동력이 필요하므로 저속의 물의 흐름은 감지를 못할 수 있다.\n- 임펠러부의 여러개의 좁은 입구들은 작은 돌맹이같은 이물질이 들어와 끼게\n  되면 회전하지 못하는 부동의 문제가 발생\n- 임펠러부가 물의 마찰, 이물질의 영향으로 마모가 되고 특성이 변해 추측식\n  유량의 오차율이 커질 수 있음\n- 외부에 강한 자석을 부착하면 회전을 강제로 멈출 수 있고 불법적인 계량값\n  조작이 가능하다.\n- 입구가 좁은 형태에서 임펠러쪽은 넓어지는 형태로 유체가 완전 발달유동이\n  아니라 저속 유량에서 오차율의 변동이 크게 생긴다.\n\n입사 2~3주 정도가 지나고 임펠러 수도미터의 파악이 위와 같이 될 무렵 초음파 수도미터\n개발은 확정되었다.\n\n<!-- > 추측식으로 발생하는 오차율의 변동성은 생산팀, 고객과의 주된 갈등 요소였다 -->\n<!-- > 이 부분에 대해 전자부의 신뢰성을 의심하였으나 대부분 문제는 완전 발당 유동이 아니며 -->\n<!-- > 조립 불량, 임펠러 회전부 불량 등으로 발생하는것으로 나는 추측했었고 분석 및 실험적으로는 증명을 했으나 이론적 증명을 명쾌하게 하지 못했다. 그래서 설명하고 이해시키고 예방하는것이 어려웠다. 아쉬움이 많이 남는다. -->\n\n### 초음파 수도미터 개발 시작\n\n총 개발 일정은 1년이지만 인증 일정을 빼면 1년이 안되는 일정이었다. 프로젝트의 인원 구성은 펌웨어 2명(관리자, 실무자), 하드웨어 2명(관리자, 실무자) 한달간 펌웨어, 하드웨어 실무자가 사전조사 및 개발방향에\n대해 매주 발표일정이 잡혔고 발표한 내용을 기반으로 토론하여 칩, 부품 선정을\n진행했다. 한달간의 사전조사로 초음파식의 장점은 위에서 기술된 임펠러의\n단점들을 개선할 수 있을것으로 보였으나 유량부의 가격이 상대적으로 비싼 부분이 압도적인\n단점이었다. 😢\n\n수도미터 업계(라 하고 대부분의 임베디드 제품)는 가격이 가장\n중요한 요소임을 부정할 수 없다. 제품의 개발이 완료되어도 제품이 잘 팔릴\n수 있을지 의문이었지만 연구비 지원으로 개발비가\n사실상 들지 않고 회사 제품의 다각화 및 기술력 홍보의 일환으로 프로젝트는\n진행되었다.\n\n## 그래서 초음파 수도미터가 임펠러보다 뭐가 좋은데❓\n\n초음파는 사람의 가청이 불가능한 20㎑ 이상의 음향적 진동을 초음파라 한다. 초음파는 빛이나 전파와 같은 파동 에너지이지만 전파 속도가 늦고, 반사하기 쉬운 특성이 있다.\n\n### 초음파 수도미터의 기본 원리\n\n초음파 수도미터는 두개의 압전 센서가 유량부에 설치된다\n\n> 압전 센서(Piezo Sensor)는 전기적 신호를 진동으로 변환하여 초음파를\n> 발생시키거나 역으로 진동을 전기적 신호로 변환시켜주는 센서 따라서 음파의 송, 수신이\n> 둘다 가능하다\n\n![UltrasonicSensor](./img/ultrasonicSensor.jpg)\n\n압전센서에서 발생된 초음파는 유체(물)을 통과하며 그림과 같이 T1, T2\n두개의 경로로 송수신 한다 초음파의 특성은 물리학에서 말하기를 파동이며 종파라 한다\n종파는 매질의 진동 방향과 파동의 진행 방향이 서로 평행한 파동을 말한다\n\n> 여기서 T1, T2는 해당 경로로 초음파 송신 후 수신되는 시간이다 TOF(Time Of\n> Flight)라고도 한다.\n\n![종파](./img/longitudinalwave.png)\n\n매질의 진동 방향과 파동이 진행 방향이 같은게 어떤 의미인가? 파동의 속도가\n매질의 속도에 영향을 받는다는 것이다. 첨부 그림의 유량부의 물이 흐를경우 T1은 V만큼\n빨라질 것이며 T2는 V만큼 느려진다.\n\n위의 원리를 초음파 수도미터에서 적용하는 Equation 도출은 아래와 같다.\n\n![CalcTOFEquation](./img/calcTofEquation.jpg)\n\n초음파 수도미터 칩을 제공하는 회사의 주장은 tAB, tBA를 정밀하게 측정을\n해준다는 것이고 사용자 환경에 따른 d, L값의 변수만 입력하면 정확한 유량을\n구할수 있다는 것이다\n\n### 칩, 유량부 선정\n\n한달간의 사전 조사 및 발표로 초음파 수도미터로 사용할 수 있는 칩들은\n공통적으로 기본 원리가 위와 같았다. 회사는 Texas Instrument의 저전력 칩들을\n대부분의 제품에서 사용하고 있었고 때마침 TI에서 초음파 수도미터 칩을 Release하여 추가적인 칩의 공부 시간이 절약되는\nTI제품라인을 사용하기로 결정했고, 해당 칩을 사용하면 기능들을 라이브러리로\n제공해주기 때문에 어려울 것이 없어 보였다.\n\n> arm, atmega만 써봤지만 근본적 구조는 비슷하니 어려운 점은 없었다.\n> 오히려 arm에 비해 쉬운 칩이었다\n\n> 나중에 개발도중 생각지도 못한 문제점들이 나오면서\n> 폭포수 모델의 개발방법론의 단점을 체감했다. 애자일한 개발을 하자.\n\n유량부는 구매하여 사용하기로 결정되었고 가격문제로 저가의 Made in\nChina 제품으로 결정 제품의 최종 모양새는 아래와 같아졌다.\n\n![flowmeter](./docs/img/flowmeter2.jpg)\n\n##### Figure [TI 초음파 유량계]\n\n#### Texas Instrument Ultrasonic sensing solution\n\n칩과 임베디드 개발에 대한 이해는 Chip DataSheet로 시작해서\nChip DataSheet로 끝나지만 글이 너무 길어지며 글의 목적에서 벗어나는 듯 하여\n해당 부분은 생략하고 넘어간다\n\n칩은 MSP430FR6047이라는 이름의 초음파 수도미터 전용 칩이며 TI에서는 관련\n라이브러리로 USS(Ultrasonic Software Library)를 제공한다 그 구성도는 아래와\n같은데 간단하게 말하면 TI 가라사대 필요한 기능들 Library형태로 다 만들어 놨으니까\n필요한 API만 사용하면 된다라고 주장하는 문서인데 글을 작성하는 지금은 최신 버전의 그림을 가져와서 Calibration 기능이 포함되어 있는데 당시 개발할 때는 Calibration 기능이 존재하지 않았다.\n\n저 문제가 후에 작성할 내용의 주된 내용이며 이글을 작성하는 이유다.......😥\n\n![USSArchitecture](./img/USSArchitecture.png)\n\n> 라이브러리에 Calibration기능이 추가된 이후에 비교 검토 결과 TI기능은 양산, 출하과정 이점이 떨어져 이 글의 방법을 유지했다.\n\n# 본론\n\n## 개발 시작\n\n### 유량 산출 알고리즘\n\nMSP430FR6047 칩과 유량부를 받고 USS Library를 사용하여 유량을 구하는 코드를\n작성했다 해당 라이브러리의 Parameter의 이해와 User 설정값을 찾아내는 과정은 생략하고 공식 가이드 링크로 대체한다. 공식 Guide문서를\n읽으면 충분하기 때문이다.\n<a href=\"https://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/USSSWLib/USSSWLibWater/latest/\">USS Library Guide</a>\n\n유량을 구하는 알고리즘을 간략화 하면다음 1~5번을 주기적으로 반복 하는\n것이었다.\n\n1. 압전 센서를 이용해 TOF1, TOF2를 구한다\n2. DTOF = TOF1 - TOF2를 구한다\n3. 산출된 DTOF를 USS Library에 파라메터로 넘긴다.\n4. USS Library는 유속(V)를 Return한다.\n5. 자사의 유량부 면적(A) \\* 유속(V) \\* 측정 시간 주기 = 체적 유량(VolumeFlow)이다\n\n![IdealVolumeFlow](./img/idealVolume.jpg)\n\n### 문제 발생\n\n호기롭게 유량측정 테스트를 하러 갔다 테스트 장비는 그림과 같이 생겼는데 FlowMeter를 시험대에 걸어 물을 흘리고 Meter의 유량값과\n초록색 물통의 실제 유량을 비교하는 방식으로 진행된다\n\n테스트를 해보니 그 정밀하다는 초음파 FlowMeter의 유량값과 TestBench의 오차율이 컸다.\n코드를 다시 점검해도 Library의 사용법부터 유량 계산 알고리즘의 기본 전제는 틀리진 않았고 무언가 예상치 못한\n문제가 있다고 생각했다.\n\n![testbench](./img/testbench.jpg)\n\n## 문제의 원인을 찾자❗\n\n고민을 했지만 문제의 원인을 알 수 없었고 내가 파악하지 못한 변수가 유량값에 영향을 끼친다고 결론을 내렸다.\n당시에 AI, Deep Learning, 통계학의 주요 컨셉을 흥미로 가볍게 보고 있었는데 지금 문제를 해결하기 좋은 방식이라는 생각이 들었고 모방하기로 결정했다.\n\n모방하기로 한 방식은 라벨링된 데이터(정답지)로 입력변수와 결과의 상관계수를 찾아내는\n법이다. 현재 라벨링된 데이터는 TestBench의 유량 결과로 가정하고, 입력변수는 TestBench의 유속 설정, 물의 온도, 실험한 총 유량의 값...기타 등등으로 가정하여 확보할 수 있는 최대한 많은 입력 변수를 전부 기록하기로 했고 시험 FlowMeter의 개수도 최대한으로 늘려 일주일정도를 실험만 돌려 데이터를 확보했다. 실험중 나온 데이터는 Python을 통해 분류 및 저장을 편하게 할까 잠시 고민했지만 배보다 배꼽이 큰거같아 수동으로 엑셀로 정리하였다.\n\n데이터를 엑셀의 분석도구를 활용해 오차율이 높아지는 상관계수는 물의 온도,\n시험대의 유속 두가지 변수가 높다는걸 알게되었다. 이 문제가 유체와 관련된 문제임을 알게되었고\n명확한 원인 파악을 위해 내 업무시간은 코딩이 아니라 유체역학을 공부하는 것이\n되었다\n\n### 유체역학 학습으로 추론한 문제의 원인\n\n#### USS 평균유속 문제점\n\n유체역학 이론에 따르면 실제 파이프에는 마찰로 인해 층류(Laminal) 및 난류(Turbulent)형태로 흐른다 따라서 기존 유량 산출 알고리즘은 USS Library로 파이프 중앙의 유속을 측정하고 Firctionless Flow로 가정하여 평균 유속을 구하므로 층/난류 정도에 따라 평균유속의 오차가 발생한다.\n\n> 여기서 마찰은 파이프 벽면과 물의 마찰 뿐만 아니라 같은 물분자 끼리도 마찰의 성질이 작용한다. 난류의 정확한 해석은 여전히 미제(謎題)라고도 한다.\n\n![Flow_Illustration](./docs/img/Flow_Illustration.jpg)\n\n**Frictionless flow**: 모든 영역에서 동일한 속도로 흐르는 유체\n(이상적 유체이며 내가 상상한 물의 흐름이었다)<br/>\n**Laminar flow**: 유체 속도가 벽 근처(마찰이 더 많은 곳)에서 가장 느리고 중앙(마찰이 적은 곳)에서 가장 빠름. 점성이 높고 유체의 속도가 느릴때 보이는 흐름.<br/>\n**Turbulent flow**: 유체가 모든 방향으로 질서없이 흐르는 상황을 나타냅니다. 이것은 벽의 덜 매끄러울때, 점성이 낮고 유체의 속도가 빠를때 보이는 흐름.\n\n#### 층/난류의 정도를 결정 짓는 변수\n\n그렇다면 이 문제를 해결하기 위해선 층류와 난류가 발생하는 이유 및 정도를 입력변수들로 예측할\n수 있어야 하는것으로 귀결된다 그것또한 위대한 과학자 뉴턴, 레이놀즈가 실마리를 친절하게\n알려주신다.\n\n### 뉴턴 유체(Velocity Profile의 선형성)\n\n#### 유체의 정의\n\n물질 내의 응력이 그 물질의 변형률의 시간변화율의 함수로 나타내어지는 물질<br/>\n외부에서 전단응력(shear stress)이 작용하면 그 힘이 아무리 작더라도 연속적으로 변형하는 것.\n\n- 전단응력(단위 τ)\n\n면적 / 단면적에 평행 한 힘\n\n> 두꺼운 책을 놓고 책 표지에 손바닥을 댄 다음 옆으로 민다고 생각해보자. 이때 책의 옆면은 직사각형에서 평행사변형 형태로 변형될 것이다. 이것이 바로 전단응력과 전단응력에 의한 변형이다. 파이프 내의 물의 흐름과 유사하다.\n\n#### 수도미터 유체 특성\n\n초음파 수도미터는 액체상태의 물의 특성만을 가정한다. 물은 아래와 같은 특성을 지닌다.\n\n**비압축성 유체** :\n압력에 따른 밀도 변화가 무시할수 있을만큼 작다<br/>\n**점성 유체** :\n유체의 흐름을 방해하는 저항 성질이 존재<br/>\n**연속체** :\n유체내에서 연속적으로 변하는 유체의 성질. 성질변화가 대단히 완만하여 그 물\n질을 해석하는데 미분학을 사용할 수 있다는 것을 의미<br/>\n**등방성** :\n특성이 모든 방향을 따라 동일함.<br/>\n\n> 실제로 모든 유체는 점성이 있고 압축성이기 때문에 이상유체를 가정할 수 없지만,\n> 점성과 압축성의 효과가 매우 작은 유체의 경우는 일반적으로 이상유체로 가정한다.\n\n#### 전단응력과 점성 그리고 유체속도\n\n전단응력이 가해지면 유체는 연속적으로 변화하므로, 그림에서 보듯이, 전단응력 τ가 한 평면에\n작용할 때, 위 표면은 아래 표면 보다 𝛿u만큼 큰 속력으로 움직이며, 전단변형각 𝛿θ은 시간에 따라 계속적으로 커질 것이다. 이때 뉴턴 유체의 경우 작용된 전단과 그\n로 인해 발생하는 변형률 사이에 선형비례관계가 정의된다.\n\n이때 비례상수가 점성계수이며 차원의 동차성에 의해 점성계수는 응력-시간의 차원을 갖으며 단\n위는 N sec/m2 이다\n\n- 이렇게 전단응력과 유체의 속도사이에 **선형관계**(**예측가능**)를 만족하는 유체를 Newtonian 혹은 Newton Fluid라 한다.\n- 유체역학에서는 일반적으로 변형각보다는 속도분포(Velocity profile)에 관심이 있다\n\n![sheerStress](./docs/img/shear_stresss.png)\n\n수학적 방적식으로는 아래와 같다.\n\n![newton_equation](./docs/img/newton_equation.png)\n\nτ : 전단응력\nu : 점성계수\ndu/dx : 전단 변형률\n\n위와같이 뉴턴 유체의 특성으로 인해 초음파 수도미터에서 측정한 평균 유속(Frictionless 평균 유속)은 실제 전단 응력, 점도에 따른 실제 평균 유속(속도분포[Velocity profile])이 다름을 알수있다.\n\n그리고 물은 뉴턴 유체의 성질로 인해 이상적 유체(Frictionless Flow)와 실제 유체(층,난류)의 오차율은 점성, 𝛿u(속도, 입출구의 압력차) 두가지 변수에 **선형적**이라 추측할 수 있다.\n\n> 기존 초음파 수도미터들의 특허를 찾아본 결과 이러한 이유로 다회선식 초음파 센서로\n> 정밀하게 측정하는 방식들을 제시한다. 회선이 늘어날 수록 정밀한 Velocity profile 측정이 가능할 것으로 보이나\n> 비용의 증가로 해당 방식을 적용할순 없었다.\n\n### 레이놀즈 수(Reynolds Number)\n\n\"관성에 의한 힘\"과 \"점성에 의한 힘(viscous force)\"의 비로서, 주어진 유동 조건에서 이 두 종류의 힘의 상대적인 역학관계를 정량적으로 나타낸다.\n\n레이놀즈 수는 유체 동역학에서 가장 중요한 무차원 수 중 하나이며, 다른 무차원 수들과 함께 사용되어 동적 상사성(dynamic similitude)을 판별하는 기준이 된다. 두 유동 패턴이 기하학적으로 상사일 때, 이 두 유동의 주요 무차원 수들이 동일한 값을 가지면, 이 두 유동이 동적 상사성을 가졌다고 말하며 이 두 유동은 그 형태가 유사하게 된다.\n\n이 동적 상사성의 특징은 두가지의 합리적인 가설을 제공해준다.\n\n1. 초음파 수도미터의 속도 분포의 뉴턴 유체의 특성으로 변수는 점도(점성), 전단응력의 세기(관성)이다. 또한 레이놀즈 수의 상사성의 원리를 이용하여 점성, 관성이 다를지라도 레이놀즈 수가 같다면 같은 Velocity Profile로 나올것으로 생각할 수 있다.\n2. 다양한 초음파 수도미터는 면적, 모양이 같아(엄밀히 말하면 미세한 차이이므로\n   무시해도 좋은) 동적 상사성 관계를 만족하므로 동일한 보정 알고리즘이 적용가능.\n\n또한 레이놀즈 수는 또한 유동이 층류인지 난류인지를 예측하는 데에도 사용된다.\n하지만 초음파 수도미터 오차 보정에 필요한 것은 Velocity Profile뿐이므로 층류\n난류의 구분은 무시하고 동적 상사성만 주목한다.\n\n![reynolds_number](./docs/img/reynolds_number.png)\n\n여기에서 vs는 유체의 평균 속도, L은 특성 길이(characteristic length), u 는 유체의 점성 계수(Dynamic Viscosity), v 는 유체의 동점성 계수(Kinematic Viscosity), p는 유체의 밀도이다.\n\n앞서 살펴본 물의 비압축성으로 나는 유체의 밀도는 무시했다.\n\n> 기존 Reynolds Number Equation의 vs는 유체의 평균속도(결국 Velocity\n> Profile)이지만 나는 점성과 관성력의 비율만 관심이 있으므로 유체의 평균속도가\n> 아닌 유체 중심의 속도로 대체했다.\n\n### vs(유체의 중심 속도) u(점성계수) 구하기\n\n위에서 살펴본 이론들을 배경으로 뉴턴 유체의 특성으로 발생되는 선형적인 오차 변화를 예측하는게 알고리즘에 적용되어야 한다. 즉 Velocity Profile Factor의 변수는 Reynolds Number(점도, 유체 중심의 속도)이니 두개 변수를 알면 오차 보정이 가능할 것으로 보인다.\n\n- 기존 알고리즘 결과는 유체의 중심 속도[𝛿u]를 제공.\n\n물의 점도는 현재 알고 있는 변수가 아니다. 하지만 물의 온도는 다음과 같은 과정으로\n구할 수 있다.\n\n#### 물의 온도 구하기\n\nUSS Library는 TOF(Time of Flight)를 제공한다.\n\n- 비행거리는 일정하다 (상수)\n- TOF는 매번 측정되는 변수\n\n![equation](https://latex.codecogs.com/gif.latex?Ultrasound&space;Speed&space;=&space;\\frac{Distance}{Time&space;of&space;Flight})\n\nTimeofFlight = (tAB + tBA) / 2\n\n따라서 온도는 비행속도로 구할수가 있다. C(초음파 속도)와 수온의 관계는 아래의 그래프와 같다.\n\n![sound_velocity_water](./img/tempSoundVelocityInWater.png)\n\n하지만 위의 방정식은 무려 5차 방정식이었고 1차 전지를 사용하는 수도미터에서\n고차원 방정식을 매번 연산하기는 배터리 소모가 크므로 Lookup Table 방식으로\n온도를 구하는 방식을 선택했다.\n\n#### 물의 점도\n\n온도에 따른 물의 점도는 이미 측정된 데이터로 알려져 있다.\n\n물은 비압축성 유체이기 때문에 온도가 물의 점도를 결정하는 유일한 요소다\n점도 역시 Lookup Table로 구한다.\n\n![viscosityofwater](./docs/img/viscosityofwater.png)\n\n## 해치웠나❓ 어림 없지❗\n\n위의 문제점만 적용해도 1급 수도미터 기준의 오차율을 만족하는 것을 확인해 초기 프로젝트의 목표는 이미 달성했고, 바로 제품의 판매가 이뤄지지 않는점에서 끝내도 되는\n상황이었지만 시간적 여유가 있어 개인적인 욕심을 더 냈다.\n\n### 제품의 양산, 출하를 생각하면 문제가 되는 점\n\n![MeterErrorChart](./img/meterErrorChart.jpg)\n\n1. 수도미터 유량계는 생산시 Q3,Q2(+-2%), Q1(+-5%)의 오차율을 만족해야 하고 인증시 0.33Q3, 0.7Q3등을 더 시험 보는데 10개 수도미터의 시험데이터를 기반으로 이것을\n   모두 만족하는 구간별 Factor를 찾는 방정식을 만들어본 결과 5차가 넘는 고차방정식이었고 연산량이 커 배터리 소모가 컸다.\n\n> Q1,Q2,Q3는 각각 최소유량,전이유량,최대유량이라 하는데 수도미터가 작동할\n> 수 있는 범위내에서 특별히 오차율 시험을 보는 구간이라 보면 된다\n\n> 수도미터는 1차전지로 무려 8년의 보증기간을 요구한다\n\n2. 개별 수도미터에는 고차 방정식을 적용하면 오차율을 만족하지만 여러개의 수도미터의 시험 구간별 오차율 그래프(M1~M10)는 미묘하게 달랐고 모두를 공통으로 만족시키는 하나의 방정식은 찾지 못했다(다항식 회귀 곡선, 최소 자승법 등등)\n\n3. 제품의 초음파 측정주기가 짧을수록 정확하지만 배터리 소모는 컸다.\n\n따라서 더 낮은 연산량의 방정식과 개별 수도미터의 오차율이 허용오차를\n만족하는 방식, 측정주기 개선이 필요했다.\n\n#### 양산, 출하를 고려한 수정 사항들\n\n1. 개별의 수도미터 오차는 생산시 1회성으로 TestBench로 Q3,Q2,Q1을 시험하고 오차율 보정을 한다.\n2. 나머지 구간은 보정은 스플라인 보간법[Spline Interpolation(Piecewise Polynomial\n   Interpolation)]을 적용하여 연산량을 낮추기로 결정했다\n\n따라서 아래와 같게 된다\n\n![spline](./img/spline.jpg)\n\n3. 측정 주기는 그림과 같이 개선하여 T(주기)를 늘려도 오차율이 동일하거나 좋게\n   나오도록 했다.\n\n> v1, v2 값의 차이에 따라 T를 가변적으로 하는것도 적용했으면 좋았을 텐데\n> 그 기능을 고민할때쯤 특허 준비로 정신 없었다 😥\n\n![TimeResolution](./img/IMG_0042.jpg)\n\n### 변경된 알고리즘\n\n유속 보정 알고리즘은 다음과 같이 변경 되었고 제품 인증과 특허출원으로 마무리\n되었다.\n\n1. 압전 센서를 이용해 TOF1, TOF2를 구한다\n2. DTOF = TOF1 - TOF2를 구한다\n3. 산출된 DTOF를 USS Library에 파라메터로 넘긴다.\n4. USS Library는 중심 유속(V)를 Return한다.\n5. 자사의 유량부 면적(A) \\* 유속(V) = 체적 유량(Frictionless VolumeFlow)이다\n6. TOF에서 물의 온도 계산하기\n7. 온도 및 USS Return 유속(V)으로 현재 Reynolds Number 구하기\n8. RE값의 범위에 따라 f1또는 f2의 Spline 보간식이 적용된다\n9. Spline 보간식의 y값 (Frictionless 유량 : 실제 유량의 비율(Factor)이 나온다)\n10. 실제 유량 = Frictionless \\* Factor\n\n# 결론\n\n제품은 필드에 실제 설치되어 테스트를 진행했고, 몇개 지자체에 시범적으로 설치되어 운영되었다.\n아마 내가 퇴사하고 1년 이내 제품 판매, 영업이 적극적으로 할 것으로 보인다.\n\n1년 남짓 초음파 수도미터 개발을 진행하면서 위와같이 문제들을 해결하고\n결과적으로는 인증, 특허 등이 문제없이 마무리 되었다. 그 이후로 다른 제품\n업무를 하면서 유지보수에는 신경을 많이 못쓴 제품이었다.\n\n퇴사를 하면서 후임자에게 인수인계를 해주면서 드는 생각은 아쉬운 점들이 많은\n제품이다\n\n- 회사의 공식적인 코딩 컨벤션, 문서화 룰이 없어 내 나름대로 룰을 세우고 작성하고 룰을\n  따르려 했지만 돌아보니 미흡하다. (clangFormat, DoxyGen 사용)\n- 임펠러도 양산시 Q3,Q2,Q1 시험을 하여 2차 보정을 하지만 초음파 수도미터는\n  생산성 향상을 위해 양산시 시험 과정을 없애고 싶었으나 결국 못했다.\n  이론적으로는 가능할 것으로 보여서 더욱 아쉽다.\n\n그래도 진행하면서 뒤돌아보면 괜찮았던 점들도 있다.\n\n- 기존 임펠러식의 서술된 단점들은 모두 확실하게 개선했다\n- 위의 문제해결 과정을 문서화하고 프로젝트 인원들에게 공유하거나 후임자에게\n  인수인계를 해주는 경험은 오히려 내가 명확하게 이해하는데 도움이 되었다\n- 프로그래밍 이외의 물리학, 통계학의 지식들이 쓰여 문제를 해결하는 것은 재미있는 경험이었다.\n- 다른 국내 초음파 수도미터들의 성능, 가격 상대적 비교가 우월했으며 수도미터\n  성능이 뛰어난 독일산 제품과 비교할만 했다.\n\n다 작성하고 보니 글을 쓴다는게 참으로 많은 생각이 든다. 쓰고 지우기를 반복하며 우여곡절 끝에 하나의 포스팅을 완성했지만 아쉬운 부분이 계속해서 보이니 참으로 신기하다. 수도미터에 대한 전반지식이 없는 사람도 이해할수 있는 글을 쓴다는 생각으로\n작성을 했는데 전문가가 보면 속빈 강정이고 일반인이 보면 이해가 안가는 애매한 글이 되었나 라는 생각도 든다. 내 이야기를 써서 인터넷에 올리는 것도 여전히 쑥쓰럽다. 글을 쓰는 다양한 이유들이 있겠지만 나는 스스로를 위해 쓴다. 다른 사람에게 설명을 하다보면 내가 알고있다고 생각했던것도 어설픈 지식임을 깨닫게 된다. 내 생각을 표현하는 연습과 지식의 재점검이 주 목적이다.\n","fields":{"slug":"/ultrasonic/"},"frontmatter":{"title":"초음파 수도미터","subTitle":"초음파 수도미터 오차의 원인과 해결","date":"2021.10.10","category":"embedded","cover":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBAv/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAFlOkguP//EABgQAAMBAQAAAAAAAAAAAAAAAAABERAx/9oACAEBAAEFAoPFyER//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8Bqv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Aov/xAAaEAEBAAIDAAAAAAAAAAAAAAABABEhMVFh/9oACAEBAAE/IRdpAQ6hpYPN5X//2gAMAwEAAgADAAAAEGTv/8QAFhEBAQEAAAAAAAAAAAAAAAAAIQAB/9oACAEDAQE/EMTar//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EIf/xAAbEAACAgMBAAAAAAAAAAAAAAAAARExIUGBYf/aAAgBAQABPxCromhOblcJEcWI2dY1sJ6eA//Z","aspectRatio":1.7857142857142858,"src":"/static/8c77a93c4b81b0224e5d134f961dca50/14b42/flowmeter.jpg","srcSet":"/static/8c77a93c4b81b0224e5d134f961dca50/2c7f8/flowmeter.jpg 50w,\n/static/8c77a93c4b81b0224e5d134f961dca50/4e333/flowmeter.jpg 80w,\n/static/8c77a93c4b81b0224e5d134f961dca50/86e11/flowmeter.jpg 100w,\n/static/8c77a93c4b81b0224e5d134f961dca50/aabdf/flowmeter.jpg 150w,\n/static/8c77a93c4b81b0224e5d134f961dca50/14b42/flowmeter.jpg 800w,\n/static/8c77a93c4b81b0224e5d134f961dca50/ec6c5/flowmeter.jpg 1280w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},{"node":{"id":"6654ef8b-ae87-560a-988f-e757cdb4df76","excerpt":"서론 지금은 국민적 게임이 된 League of Legends(이하 LOL)를 2013년쯤 친구의 추천으로 시작했었고 빠르게 매료되었다. LOL은 무작위로 매칭된 10명의 인원이 5:5의 팀 형식으로 승패를\n가르는 AOS(Aeon Of Strife…","rawBody":"---\ntitle: League of Legends 랭킹은 실력인가?\nsubTitle: 게임의 실력은 어떻게 향상되는가?\ncategory: Game\ndate: 2021-10-14T12:00:00\ncover: ./img/leagueofLegends.jpg\n---\n\n# 서론\n\n지금은 국민적 게임이 된 League of Legends(이하 LOL)를 2013년쯤 친구의 추천으로 시작했었고 빠르게 매료되었다. LOL은 무작위로 매칭된 10명의 인원이 5:5의 팀 형식으로 승패를\n가르는 AOS(Aeon Of Strife) 장르의 게임이었다.\n\n> AOS란 플레이어가 하나의 캐릭터를 선택하고 그 캐릭터를 강화시켜 상대방 진영을\n> 파괴하는게 목적인 게임 장르\n\n나는 2013~2014년을 LOL의 랭크 게임, 즉 팀이 이기고 지는 결과에 따라 순위가\n변동되는 게임에 몰입했었고 순위를 더 올리고 싶어했다. 랭크 게임은 여느 스포츠와 같이 매해\n순위가 초기화 되며 1년 단위로 Season이 새로 시작하는데 나는 Season3에 시작하여 Season4까지 1~2년정도 했었다.\n\n> Season 1, 2는 미국서버만 가능했고 사실상 Season3가 한국 서버의\n> 시작이었던걸로 기억한다.\n\nSeason3는 다이아몬드 2티어로, Season4는 Master티어로 종료되었다. 당시 등급에 따른 분포비율은 아래 첨부 그림과 같았다.\n\n![rankTier](./img/Season4Rank.png)\n\n랭킹이 상위권으로 진입하면서 프로들과 매칭이 잡히기 시작했고 내가 진행하는 경기가 실시간으로 게임 Client의 모든 사람에게\n공개되었는데 이로 인해 모르는 사람에게 친추 요청이 많이 왔었고 나는 모두\n받아줬었다. 그 사람들이 친구 추가를 해서 말하는것은 크게 4개였다.\n\n1. 자신의 아이디의 랭크를 올려주면 돈을 주겠다는 대가성 요청\n2. 낮은 아이디를 가지고 있거나, 아이디를 빌려줄테니 자신과 듀오를 해달라는 요청\n3. LOL 잘하는 법을 알려달라는 요청\n4. 내 게임을 관전하고 싶어 친구 추가를 하는 요청\n\n나는 3, 4번 유형에 친구를 보며 호기심과 의문이 생겼다. 저 사람들은 랭크를 올리고 싶은데 잘 안되고 방법을 모르겠다고 했다. LOL 랭크게임은 시스템이 매번 10명을 매칭을 임의로 해주며 그렇게 매칭된 사람들이 5:5의 팀대전을 한다. 이렇듯 강한 무작위성이 있는 게임에 나와 저 사람의 순위\n차이는 정말로 실력의 차이일까? 실력의 차이라면 LOL을 잘하는 사람과 못하는 사람의 차이는 무엇인가? 어떻게 증명이 가능한가? 나는 LOL이라는 게임의 즐거움을 플레이에서 이론적 분석으로 관심이 가기 시작했다. 나는 랭킹을 올리기 위한 요소들을 정의하고 저 사람들을 코칭 해보기로 결심했다.\n\n# 본론\n\n내가 느끼기에 게임 분석은 마치 포커, 증권이론과 유사했다. 불확실성으로\n가득하고 너무나 많은 경우의 수가 존재해 정량적인 과학적 방법론만으로 진행할 수 없고\n정성적 분석이 필수적이다. 따라서 이 글은 LOL을 잘하게 하는 쉬운 공식은\n제공하지 못한다. 다만 정성적 분석이 대부분이라도 일반화 할 수 없는것들은 배제하였고 최대한 많은\n플레이어들에게 적용되는 부분만 작성했다\n\n> 당시 열정이 있는 친구를 골라 멘토링을 해주던 과정의 모든걸 짧은 포스팅 글로 설명할순 없다고\n> 느꼈다. 그래서 이 글은 최대한 멘토링 기억을 더듬으며 중요하고 공통적인 핵심만 나열한다.\n\n## LOL은 운빨 게임인가?\n\nLOL은 운적 요소가 분명히 존재한다. 랭크게임은 MMR(Matchmaking Rating)이라는\n시스템으로 나와 최대한 비슷한 실력의 플레이어들을 9명을 찾아 매칭해주려 하지만 불공평한, 운이 없는 게임이 발생한다.\n극단적으로는 상대팀에 대리 게이머, 부캐가 있을수도 있으며 우리팀에는 소위\n말하는 트롤, 어뷰저가 있을수도 있다.\n\n하지만 이러한 불운은 나에게만 적용되지 않으며 다른 플레이어도 동일하다. 반대로 나에게 유리한 운이 적용 될 수도 있다. 시행 횟수가 많아지면 통계적 확률이 수학적 확률과 가까워져 가듯이 단판이 아닌\n게임의 횟수가 많아지면 운보다 내 실력으로 승패가 판가름날 확률이 극히 높아진다.\n\n이렇게 생각하는 근거는 앞서 말한 MMR 매칭이다. LOL은 MMR을 통해 최대한 비슷한 랭킹의 사람들끼리 매칭을 해주므로 만약 내가 해당 MMR보다 월등히 뛰어난 실력인 사람이라면 게임의 횟수가 많아질수록 승률은 50%보다 높을 수 밖에 없다. 내가 특정 MMR에서 게임의 횟수가 많았는데 점수는 그대로라면 불운이 아니라 내 임계점의 점수이며 실력이다. 만약 임계 MMR보다 높은곳에서 게임을 하면 승률이 50%이하로 떨어지며 임계 점수로 되돌아 올것이다.\n\n나는 이것을 스스로 증명하기 위해 3개의 부캐를 키웠으며 MMR이 낮은구간에서는\n승률이 90%에서 내 임계점인 다이아1~마스터 구간부터 승률이 50%로 떨어지는것을\n똑같이 반복했다. 다수의 프로 플레이어들은 여러개의 아이디를 Challenger 고승률로 빠르게 달성하기도 한다.\n\n### 올라가고 싶은 플레이어에게 필수인 위닝 멘탈리티\n\n심지어 이런 상황에 어쩔수 없다고 자기합리화를 하고 게임을 포기하는것은 최악이다. 당신이 알고있는 LOL을 가장 잘한다고 생각하는 사람이 나 대신 플레이를 한다면 질것 같은지 한번 생각해보라. 나는 이런 상황에 프로가 나대신 했다면 이겼을거라 생각했다. 아무리 어렵고 불합리한 상황이라도 대부분 이기는 방법이 존재한다. 나는 꽤 많은 LOL 플레이어를 봤는데 운이 없다고 불평하는 말을 자주하는 플레이어가 점수를 올리는 경우는 보지 못했다. 랭킹을 올리고 싶은 유저라면 게임 승패의 원인을 운, 외부에서 찾지 말아야 한다. 타인에게 관대하고 나에게 엄격해져야 한다.\n\n앞에서 했던 말과는 다르게 고랭크로 갈수록 아이러니하게 성격이 좋지않은\n다혈질적 플레이어들이 많다. 하지만 재미있던 것은 고랭크 게임은 채팅으론 싸워도 게임을\n포기하지 않고 악착같이 이기려고 하는 사람이 많았다. 아무리 불리한\n게임이라도 이길 방법을 모색하는 것이다. 나는 이 위닝 멘탈리티가 있는 사람과\n없는 사람이 현재 비슷한 실력이더라도 시간이 지나면 차이가 벌어진다는데에\n장담할 수 있다.\n\n그 한판을 이기고 지는 측면에서 불리한 상황에서 최선을 다하라는 것이 아니다.\n한번의 승패는 전혀 중요하지 않다. 내가 기상학을\n연구하는 학자라고 하자. 평소처럼 맑고 좋은날은 나의 연구에 큰 도움이 되지 않는다.\n만약 보기드문 자연재해가 있는날이라면 이 사람은 평소보다 더 연구할것이 많아진다. 또한 헬스를 하는 사람이 근육을 발달시키기 위해 중량을 늘리거나 횟수를 늘리는 것처럼 LOL도 마찬가지라 생각한다. 오히려 많이 경험해왔던 일반적인 구도의\n게임이나 쉬운 게임은 내 성장에 자극이 적고 불리한 상황은 내가 학습할 수 있는 새로운 상황이\n많은 정보 엔트로피가 높은 상황이다. 나는 개인적으로 이런 불합리한\n게임일수록 최선을 다했을때 내가 만들수있는 승리패턴이 다양해지며 LOL 실력이 더 좋아지는걸 느꼈다.\n\n당신은 LOL을 계속하는 한 승리와 패배가 적힌 동전을 수없이 던질것이고 조금이라도 승리가 더 나오게\n할 방법들을 스스로 많이 알아내야 한다. 그 배움은 오히려 내가 상대방에게\n변명의 여지없이 처참하게 질때, 팀이 어려운 상황일때 더 많이 알 수 있다는것을 기억하고 최악의 상황에서도 다양한 시도를 해봐야 한다.\n\n## LOL을 잘한다는 정량적 근거들\n\n한마디로 정의하자면 LOL의 실력은 곧 판단 능력이다. 좀 더 풀어 쓰면 플레이어가 현재 관찰 가능한 정보를 세심하고 빠른 분석으로 무엇을 해야하는가를 정확히 판단하는 과정이고 뛰어난 판단을 자주하는 사람이면 랭킹이 올라간다. 이것은 AOS장르 뿐만\n아니라 FPS, 전략 시뮬레이션 게임등 대부분이 모두 동일하다고 생각한다. 그렇다면 판단능력을 올리기 위해 학습해야될 요소들은 무엇이며 이사람이 좋은 판단을 했는지 증명은 어떻게 해야할까?\n\n### LOL의 기초 체력\n\n플레이어가 이 게임내에서 가장 좋은 판단을 했는지 정량적 증명은 게임\n내에서 다음과 같은 상대적 기준을 제시한다.\n\n- 게임 내에서 Lv이 가장 높을 것\n- 게임 내에서 Gold(CS)수급량이 가장 높을 것\n- 게임 내에서 Death가 가장 적을 것\n\n이 세가지가 높다는 것은 대부분의 게임에서 군더더기 없는 정확한 판단을 했다고 생각한다. 이유를 살펴보자.\n\n> 플레이어의 Kill, Assist 수치는 기회비용적 관점으로 접근해야 한다. 솔로킬을 제외하면\n> 킬을 올리기 위해 cs, 경험치 손해를 보고 로밍을 가야한다. 플레이어는 cs, 경험치 손해보다\n> 킬의 값어치가 클 확률이 높다고 판단될 때만 로밍을 가야한다. 대부분의\n> 하위랭크 게임은 이 판단이 틀릴 경우가 많았다. 따라서\n> Kill수치는 정량적 기준에서 우선 제외한다.\n\n### 라인전 게임의 시작\n\nLOL은 정글러를 제외하고 자신의 포지션에서 상대방과 부딪히며 끊임없이 발생하는 미니언을 처치해 CS(Creep Score) 수급, Level up을 해야한다. 이를 라인전이라 하는데 게임에서 상당히 중요한 과정이다.\n\n게임내에서 Level, CS를 높이고 Death를 줄이는 것을 의식하고 플레이를 해보기 바란다.\n그것이 생각보다 쉽지 않다는걸 알게 될 것이다. 상대방 플레이어들은 내가 CS를 편하게 먹도록 가만두지 않는다. 견제를 받아내며 수급해야 한다. 또한 상대방 정글러의 갱킹도 회피해야 한다. 또한 CS는 끊임없이 생성되므로 수급량이 높다는 것은 플레이가 낭비가 없다는 의미도 된다. 역으로 당신은 상대방 플레이어의 CS수급을 방해해야 되며 성공적으로 방해할 경우 사실상 5:4의 게임이 되므로 당신은 승률은 올라갈 것이다. 앞서 말한 정략적 기초 체력이 높다는 것은 게임의 이해도가 높고, 전체적인 흐름을 명확하게 파악하고 있으며 게임내에서 가장 좋은 판단을 하고 있는 증거다.\n\n<!-- cs 수급은 LOL에서 골드를 버는 기본적인 방법이다. 미니언을 막타를 -->\n<!-- 쳐야 골드를 획득하는데 이를 이용하는게 라인전의 기본이다. -->\n<!-- 챔피언은 각자 스킬이 존재한다. 스킬은 데미지가 좋지만 맞추기가 어렵고 -->\n<!-- 쿨타임, 마나조건으로 한정적으로 사용 가능하다. -->\n<!-- 하지만 상대방이 cs 수급을 할 때 움직임이 강제되므로 스킬을 맞추기가 -->\n<!-- 쉬워진다. 당신의 cs수급은 평타를 활용하고 상대방의 cs수급은 스킬로 방해를 하는 -->\n<!-- 것에 신경써라. 당신이 잘했다면 상대방은 당신의 압박에 cs를 포기하거나 cs를 먹고 체력이 깎이는 -->\n<!-- 양자택일의 상황에 빠진다. 어느새 라인전은 유리해질 것이다. -->\n\n### 챔피언, 조합에 대한 이해가 첫걸음\n\nLOL에는 최근 플레이가 가능한 챔피언의 종류가 100개가 넘어간다. 챔피언에 대한\n이해란 내가 플레이하는 챔피언뿐만 아니라 상대팀, 우리팀에서 자주 나올수 있는\n모든 챔프언들의 적당한 이해를 의미한다. 여기서 적당한 이해란 챔피언의 생명주기, 조합적 특성이다.\n모든 챔피언을 이해할 필요는 없다. 비인기 챔피언들은 일단 몰라도 좋다. 당신의\n승률에 큰 영향이 당장은 없기 때문이다.\n\n#### 챔피언이 강한 타이밍과 약한 타이밍은 언제인가?\n\n챔피언의 생명주기 즉 강한 타이밍과 약한 타이밍은 그 챔피언의 스킬구조로 인해\n나온다. 이 부분은 매번 Riot의 패치마다 바뀌는 부분이라 매번 누군가가 알려줄\n수 없다. 스스로 이해해야 된다. 이렇게 설명을 끝낸다면 너무 막연하므로 한가지\n예를 들어 설명하려 한다.\n\n내가 칼리스타를 플레이 하고 있고 상대 라이너는 피오라를 플레이 하고 있다. 칼리스타는 원거리 공격을 기반으로\n한초반이 매우 강력한 챔피언이고 피오라는 근접 공격으로 초반은 매우 약하지만 후반에 강력해진다. 이 둘의 초반 라인전은 피오라가 숨도\n못쉴정도로 칼리스타가 강력하다. 칼리스타는 초반에 피오라의 CS 수급을\n방해해야 하고 가능하다면 초반에 박살내서 후반을 가지 않거나 후반을 가더라도\nGold,Lv 격차로 유리한 상황을 유지해야할 것이다.\n\n조금 더 구체적인 상황을 가정해보자. 피오라는\n응수(W)라는 스킬이 변수를 창출하는데 뛰어나고 패시브 스킬인 약점이 강한\n데미지를 가지고 있다. 만약 약점이 발생한 위치가 피오라가 접근하기 어렵고\n응수스킬이 빠진 상황이라면 CS에 접근도 못하게 더 강하게 압박해야 한다.\n\n하지만 피오라의 생명주기에 대한 이해가 없는 사람이 칼리스타를 플레이 한다면\n유리한것을 모르고 압박하지 않을수도 있다. 반대로 칼리스타가 강력한 것을 모르고 공격적으로\n플레이 하는 피오라는 솔로킬을 당할수도 있다. 이런 상황이 챔피언 이해가 부족해 발생하는 패배로 가는 지름길이다.\n더 나아가면 Lv, 게임 시간별로 상대방과 나의 생명주기는 달라지므로 이것까지 파악이 되어 강하게 플레이할때와 약하게 할때를 구분할 수 있다면 승률은 더 올라간다.\n\n#### 팀 조합적 특성의 의미\n\n위에서 파악한 챔피언 생명주기 특성이 완전히 변할 수 있는 요소가 있다. 우리팀과\n상대팀의 전체적인 조합적 특성이다. 롤은 5:5의 팀게임이므로 나머지 챔피언들과\n어떤 시너지가 나는지 조합적 특성은 무엇인지도 중요하다.\n\n마찬가지로 내가 칼리스타를 플레이 하고 있으며 상대방이 피오라라고 하자. 그런데\n우리 정글은 케인이고 상대정글은 리신이라고 치자. 이 구도는 칼리스타 피오라와는\n반대로 초반에 케인은 약하고 리신은 강하다. 또한 초반의 케인은 라인 개입능력이\n매우 떨어지지만 정글링은 빠르기 때문에 케인에 대한 이해도가 있는 플레이어라면 우선 풀 정글링에 집중할 것이다.\n이런 상황이 된다면 사실상 칼리스타 플레이어는 2:1에 가까운 어려운 라인전이 된다.\n\n거기에 더 암울한 상황을 가정해보자. 지금도 어려운 상황인데 우리팀 미드는\n카사딘에 상대팀 미드는 탈론이라면 칼리스타의 라인전은 사실상 3:1과 같은\n상황이다. 게임이 이렇게 되면 나는 1:1 상성이 유리함에도 피오라를 압박하기 어려워지고 게임이 정글과 미드에 의해서\n게임이 지배될 가능성이 높다. 초반이 강한 칼리스타는 장점이 사라지게 된다. 많은\n플레이어들이 이런 상황에 놓이게 되면 자기 챔피언의 초반 강력함을 포기하지\n못하고 강력한 압박을 유지하다 갱킹에 죽는다. 그리고 정글, 미드를 탓한다. 칼리스타가 죽은 것은 변명의 여지없이\n본인의 잘못이다. 현명한 플레이어는 이런 상황에서도 Death를 줄이면서 성장하는 최선을 판단을 찾아야한다.\n\n이런 상황에서도 올바른 판단은 있다. 우리팀의 카사딘, 케인은 앞서 말한대로 초반이 약하지만 후반이 매우 강하다.\n따라서 현명한 칼리스타 플레이어라면 내가 죽지 않는 선에서 적당히 압박해야하며\n압박이 불가능하다고 판단되면 오히려 카사딘, 케인을 서포팅하며 후반게임을 도모해야 한다.\n\n#### LOL에서 밴픽은 인게임 플레이만큼 중요하다\n\n올바른 밴픽과 인게임 플레이는 플레이어의 챔피언 이해도와 비례한다. 스스로 상황에 맞게 좋은 챔피언들을 고를\n수 있어야 한다. 챔피언은 위에서 살펴봤듯이 고유의 장단점으로 상성관계가 존재한다. 그래서 앞서 말한 피오라,잭스같은 초반이 약하고 후반이 강한 챔피언을 밴픽단계에서 상대방 라이너, 우리팀 정글,미드가 무엇인지 모르는 상태에서 먼저 뽑기 쉽지 않다. 가장 좋은 픽은 상대방의 챔프를 보고 카운터이며 후반캐리력이 높은 챔피언을 픽하는 것이다. 부득이 하게 선픽을 할 경우 후반캐리력을 조금 포기하더라도 카운터가 힘든 제이스와 같은 무상성에 가까운 챔피언을 픽해야 한다.\n\n> 솔로랭크의 챔피언 밴픽은 프로들의 대회와 그 특성이 다르다. 조합적 특성은\n> 플레이어의 실력에 따라 달라지기 때문이다. 해설자, 프로들의 밴픽을\n> 참고하되 비판적인 사고없이 맹신하면 안된다.\n\n## LOL의 정성적 요소들\n\n하지만 게임은 정량적인 조건대로 흘러가지 않는다. 프로들의 세계에선 밴픽단계만으로\n어느정도 승패를 점칠 수 있지만 솔로랭크는 다르다. 다양한 플레이어들의 실력, 챔피언\n이해도를 예측할 수 없기 때문이다. 플레이어의 실력은 밴픽단계에서는 알 수 없는 미지수다. 당신은\n인게임 플레이에서 빠르게 플레이어들의 실력을 가늠해야 한다. LOL이 재미있는\n이유다.\n\n### 조합적 특성은 파일럿의 영향을 받는다\n\n하위티어 랭크게임은 앞서 말한 조합적 특성대로 흘러가지 않을\n수 있다. 가장 큰 요인은 플레이어들의 이해도와 실력이다. 칼리스타를 플레이\n해도 초반 강점을 못살리는 플레이어도 있고 카사딘을 플레이해도 후반 캐리력이\n약할 수 있다.\n\n이런 상황에서 게임의 운적요소를 최소화 하는 방법은 빠르게 플레이어의 실력을\n판단하는 것이다. 초반이 강력한 챔프의 플레이어가 정량적 근거가 좋다면\n지원하라. 후반 캐리를 맡은 플레이어가 여러명이라면 앞에서 말한 3가지\n정량적 요소가 가장 높은 플레이어에게 집중해서 보조하라. 게임의 승률이 올라갈\n것이다.\n\n> 다른 카사딘 플레이어를 서포팅 했는데 후반 캐리를 못했다고 하여 비방할 필요 없다. 이렇게 게임을 패배한 뒤 비방하는건 의미없는 일이고 그것 또한 당신의 판단미스다.\n> 당신은 게임 중간 정량적 기준치와 플레이를 보며 카사딘 플레이어가 후반 캐리가 가능한지를\n> 판단할 여지가 있다. 카사딘 후반 캐리가 힘들것으로 판단되면 차선책을 찾아라. 이기는 방법은 다양하게 존재한다.\n\n### 랭킹이 낮은 구간일수록 게임은 후반으로 갈 확률이 높다\n\n칼리스타 사례와 같이 초반의 강력함을 바탕으로 지속해서 이득을 창출하여 복리로\n굴리는 행위를 스노우볼이라고도 한다. 하지만 스노우볼 플레이는 난이도가 높고 팀적 도움이 있을때 그 효과가 큰데 하위 랭크 구간일수록 이런 스노우볼을 굴려\n게임을 빠르게 끝내는 방법을 모르는 플레이어가 많다. 그래서 스노우볼 플레이는\n많이 실패하며 게임은 후반으로 갈 확률이\n높아 후반에 강력한 챔피언을 고른 챔프가 게임을 지배하게 된다.\n\n앞서 예를든 칼리스타 게임에서 후반게임으로 진입했으며 아군 카사딘, 케인이 성장을\n잘 한 상태라고 가정해보자. 분명 후반이 강한 챔피언이므로 게임 캐리를\n기대하지만 불운하게도 둘다 실력이 떨어지는 플레이어라면 게임은 패배할 확률이\n올라간다.\n\n따라서 나는 랭크가 낮을수록 타인의 캐리를 기대해야 되는(자신의 승리를 운에 맡기는) 칼리스타 같은 상황의 챔피언보다는 피오라같이\n후반에 게임을 지배하는 챔피언을 하길 권유한다. 때때로 패치에 따라\n초반~후반까지 모두 강력한 OP(Over Power)챔피언도 있으니 잘 찾아 활용하는 것도\n승률을 올리는 것도 도움된다.\n\n> 흔히 착각하여 실수하는 경우는 팀적 조합을 위해서 캐리력이 약하거나 숙련도가 낮은 챔피언을 고르는 경우다.\n> 프로들의 대회와 같이 서로간의 이해와 합이 맞춰진 5명의 고정 팀이라면 팀적 조합이 매우 중요하지만 솔로랭크는 아니다.\n> 검증이 안된 무작위 타인에게 의지할 필요가 있는 챔피언을 픽하는 것은 득보다 실이 많을 것이다.\n\n### 불운한 게임을 이기는 방법\n\n아주 운이 없게도 팀원들이 실력이 상대보다 전체적으로 떨어진다고 가정하자. 아군\n라이너들은 상대방에게 솔킬을 당하거나 갱킹에 당해서 계속해서 죽어 적팀의\n기초체력이 계속해서 강해진다면 당신은 리스크 있는 플레이를 통해 상대방의\n성장을 줄여야하고 내 성장은 가속해야한다.\n\n리스크 있는 플레이의 예는 다음과 같다. 위의 칼리스타와 같은 상황에서 정글의 갱킹이 위협적이지만 공격적인 압박을 유지하는 플레이를 해야한다.\n상대방의 갱킹을 논타겟 스킬을 피하거나 점멸 스펠을 이용해서 피하는 일종의\n불확실한 하이리스크 하이리턴 플레이를 감행해야 한다. 만약 성공한다면\n상대방 정글의 성장 시간을 줄이는 효과와 아군의 성장 시간을 보장해준다. 혹은 갱킹이 오기도 전에 강력한 압박으로 상대방을 솔킬을 내야한다. 상대방의 성장보다 내가 더 빨리 성장하여 게임을 지배할 수 있다.\n\n게임이 어려울때마다 이런 리스크있는 플레이들을 찾아서 시도하길 바란다. 당신의\n캐리력이 한층 올라가 불운한 게임도 더 많이 이기게 될 것이다. 어차피 당신이 게임 상황이 안좋다고 판단한 것이 정확하다면\n리스크 없는 플레이만 한다면 게임은 진다.\n\n> 리스크 있는 플레이가 힘들다면 갱킹을 자꾸 당해 죽는 아군 라이너에게 당신이 채팅, 핑으로 위험신호를 미리\n> 주거나 조언을 시도해라. 아군 플레이어는 이미 실패한 플레이로 인한 스트레스로 시한폭탄과 같다. 이 채팅과 핑은 사려깊게 해야된다. 사려깊게 한 조언에도 바뀌는게 없다면 포기하고 당신의 플레이에만 집중하면 된다.\n\n### 후반 게임은 결국 한타\n\n한타란 라인전 단계가 끝나 결국 5:5의 정면 충돌을 의미한다. 프로게임에서는\n운영으로 한타를 피해 승리하기도 하지만 솔로랭크는 매우 드물다. 결국 한타가\n열리고 게임의 승패가 갈린다.\n\n이 한타의 능력도 결국 기초 체력으로 인한 성장차이, 챔피언 조합 이해에서\n벗어나지 않는다. 당신이 원딜, 미드와 같은 딜러진이라면 기초 체력으로 성장을 많이 했어야 하며 상대방의 어떤 스킬이 위협적인지 먼저 예측해야하고 대비해야 한다. 정글, 서폿과 같은 탱커류라면 수적 우위, 상대방의 핵심스킬이 빠졌는지를 빠르게 판단해 강제로\n싸움을 열어 아군 딜러의 포지션이 우월하도록 신경써야 한다.\n\n> 여기서 다수가 공감하지 않을 수 있으나 소위 말하는 라인전, 한타의 피지컬을 나는 정말 동체시력과 같은 신체적인 능력은 크지 않다고 생각한다.\n> 플레이어의 챔피언 이해도를 기반으로 상상할 수 있는 범위가 넓어지면 예측을 통해 다른 사람보다 뛰어난 반응을 하는 과정이라 생각한다.\n> 그래서 나는 챔피언 이해도와 인게임 플레이어 실력판단은 게임 처음부터 끝까지 중요하다 생각한다.\n\n# 결론\n\n이렇듯 LOL에서 좋은 판단은 플레이어의 능력, 챔프의 조합에 따라 너무 많은\n경우의 수가 존재해 개인 멘토링을 하지 않는이상 짧은 포스팅으로 모든걸 설명할 수 없다는 한계를 느낀다. 하지만\n왕도는 있다.\n\n## 결국 랭크업의 비결은 자신의 능력의 범위를 알고 넓히는 것\n\nLOL의 실력 상승은 메타인지 능력에서부터 시작한다. 잘못된 판단을\n옳다고 믿고있는 플레이어들이 많다. 알고있는것과 알고있다고 착각하는 것을\n구분하지 못하는 것이다. 내가 못한것을 복기하고 교정하는 사람이 판수가 많아질수록 더욱 높은 MMR로 간다. 당신이 게임을 이기던 지던 한판에 하나씩 잘못된 점을 교정할 수 있다면 프로가 될 수 있을것이다.\n\n하지만 LOL은 실시간으로 게임이 복잡하게 진행되며 내가 잘한건지 못한건지 정답지가 없다.\nReplay기능을 지원하지만 Replay로 복기를 하더라도 스스로의 잘못을 명확하게 알기가\n힘들다. 플레이어들은 아는것과 모르는것을 구분하기 힘들며 착각하기 쉽다. 실력\n향상이 막혀버린다. 그래서 나는 두가지 방법을 제시한다\n\n1. 무의식적인 플레이는 교정이 어려워 성장이 느려진다. 좋은 판단과 플레이는 근거가 있어야 한다. 당신의 챔피언 픽, 인게임 플레이, 더 나아가 마우스, 키보드 누름 하나하나를 목적 의식을 가지고 해보길 바란다. 그리고 그렇게 플레이한 이유를 스스로에게 설명해보라. 합리적이지 않은 플레이가 보일것이다.\n\n2. 평소에 관심이 있고 잘하는 프로, BJ의 방송을 보면서 내가 해왔던 플레이와 잘하는 사람의 플레이를 비교, 분석, 관찰하길 권유한다. 랭크가 실력이라는 관점을 인정한다면 이 사람이 플레이하는 방식은 적어도 나보다 정답에 가깝다는걸 인정하고\n   내 생각과 다른 플레이가 나오면 왜 잘하는 사람은 저렇게 하는지 나름의 해석을 해보고 실제 플레이에서 그것이 맞는지, 나도 할 수 있는건지 확인하는 과정을 반복할 수 있다. 플레이어에게 정답지가 주어진다.\n\n흔히들 게임은 타고난 재능의 영역이라고들 한다. 당신의 목표가 어디냐에 따라 다르다. 대다수가 노력해도 유명한 프로게이머인 Faker는 될수 없을지 모른다. 하지만 앞서 말한 근거들만 발전시키더라도 최소 Diamond, 더 나아가 고랭크까지 갈수 있다는걸 의심치 않으며 나는 검증을 위해 몇명의 위닝 멘탈리티가 있는\n사람을 이러한 멘토링 과정으로만 Diamond까지 스스로 갈수있는 실력을 만들어 주었다. 심지어 몇몇은 현생에 복귀해 게임을 접은 나보다 잘해져 Challenger를 갔다.\n\n게임이 불리하던, 유리하던 스스로 엄격한 태도를 관철하고 외부에서 핑계를 찾지\n말아야한다. 그 게임이 어떠했던 당신은 완벽하지 않았고 고칠점은 분명히 존재한다. 설령 당신이 프로게이머라\n할지라도\n","fields":{"slug":"/leagueOfLegends/"},"frontmatter":{"title":"League of Legends 랭킹은 실력인가?","subTitle":"게임의 실력은 어떻게 향상되는가?","date":"2021.10.14","category":"Game","cover":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAgX/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQP/2gAMAwEAAhADEAAAAc1tBiixIs//xAAbEAACAQUAAAAAAAAAAAAAAAAAAgEDERIhMf/aAAgBAQABBQKktzGDYo3WP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AUf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwGn/8QAFhAAAwAAAAAAAAAAAAAAAAAAACBR/9oACAEBAAY/Air/AP/EABoQAAMBAQEBAAAAAAAAAAAAAAABESFRMWH/2gAIAQEAAT8h0tuThJP34Y2rlgzVnDCQ09P/2gAMAwEAAgADAAAAEHQ//8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAh/9oACAEDAQE/EMTSTf/EABcRAQADAAAAAAAAAAAAAAAAAAEQESH/2gAIAQIBAT8QS2Mf/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARMSFB/9oACAEBAAE/EBtHDsXTSqAI6XHwaqVFIPhibKsyAFAqaz//2Q==","aspectRatio":1.9230769230769231,"src":"/static/2e582ae9fae8b0b396ca46ff21fd47a8/14b42/leagueofLegends.jpg","srcSet":"/static/2e582ae9fae8b0b396ca46ff21fd47a8/2c7f8/leagueofLegends.jpg 50w,\n/static/2e582ae9fae8b0b396ca46ff21fd47a8/4e333/leagueofLegends.jpg 80w,\n/static/2e582ae9fae8b0b396ca46ff21fd47a8/86e11/leagueofLegends.jpg 100w,\n/static/2e582ae9fae8b0b396ca46ff21fd47a8/aabdf/leagueofLegends.jpg 150w,\n/static/2e582ae9fae8b0b396ca46ff21fd47a8/14b42/leagueofLegends.jpg 800w,\n/static/2e582ae9fae8b0b396ca46ff21fd47a8/47498/leagueofLegends.jpg 1200w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},{"node":{"id":"9b3b6aee-2d8c-512d-8ae6-fe5ad6a848ed","excerpt":"The source code for this blog, you can see in  https://github.com/bradkim06/clone_greg_blog.git . bradkim06 | Embedded Engineer Contact…","rawBody":"---\ntitle: About Me\n---\n\nThe source code for this blog, you can see in https://github.com/bradkim06/clone_greg_blog.git.\n\n# bradkim06 | Embedded Engineer\n\n<aside>\n📌 5년 차, 임베디드 개발자 김준수입니다.\n</aside>\n\n### Contact.\n\nbradkim06@gmail.com\n\n---\n\n# Introduce.\n\n주로 임베디드 개발을 담당했으며 필요에 따라 백엔드 개발을 겸했습니다. 다양한 IoT 제품을 양산하고 개선한 경험이 있습니다. 큰 임팩트는 혼자가 아닌 함께 만들 수 있다고 생각하기에 다양한 직무의 구성원, 회사들과 적극적으로 커뮤니케이션하며 `협업`해왔습니다.\n\n품질을 향상시켜 `비즈니스 성장`에 기여하는 일을 최우선으로 합니다.\n\n- 다양한 임베디드 스킬로 제품의 불량률을 크게 개선한 경험\n- 회사 최초로 제품 무선 업데이트(FOTA)를 개발하여 적용해 영업이익을 극대화한 경험이 있습니다.\n\n호기심을 기반으로 새로운걸 `학습`해 비즈니스에 적용하는걸 즐깁니다.\n\n- Fluid Mechanics, Regression Analysis를 학습해 신규 특허 출원\n- 아름다운 문제해결, 어려운 의사결정을 위한 데이터 수집, 통계처리 백엔드 개발 경험이 있습니다.\n\n---\n\n# Work Experience.\n\n## 하이텍앤솔\n\n2022.01 ~ 2023.03 `1년 2개월`\n\n수도 원격검침 시스템 임베디드/백엔드 개발자로 근무하며 신규 매출, 영업이익 증가에 기여했습니다\n\n### FOTA(Firmware Over The Air)\n\nFirmware 무선 업데이트 시스템 전체 설계/개발\n\n**_기술_**\n\n- Full/Delta Upgrade 서버를 Go,MySQL,Redis로 개발\n- Linker Script를 이용한 Memory Layout 최적화로 Update Size 감소\n- Fimrware 무결성 검증을 위한 Second-stage Bootloader 개발\n\n**_성과_**\n\n- 3,000대 FOTA 성공\n- 업데이트 비용 감소로 A/S, 생산팀 업무 효율, 영업이익 증가\n- 제안서 핵심 기술로 인정받아 매출 증가\n\n### Mueller사 RFP SW 연구개발 책임자\n\nMueller사 RFP(초음파 수도 계량기 납품 공급 계약) 연구, 시험 과제 진행.\n\n**_기술_**\n\n- Fluid Mechanics 기반 Spool Piece 구조 설계, 알고리즘 개발\n- AWWA Standard 분석, 개발\n\n**_성과_**\n\n- LG이노텍에 알고리즘 로열티, Spool Piece 판매 계약으로 신규 매출 발생\n\n### 수도 IoT 데이터 관리 서버\n\nC++, Go, Python으로 API, 데이터 수집, 통계 백엔드를 개발했습니다.\n\n**_기술_**\n\n- IoT 데이터 수집 Socket, REST API, LWM2M Interface\n- Unit Test 작성으로 안정성 향상 Coverage: 0% → 55%\n- 통계 처리 로직 개발, 에러 처리 및 모니터링 효율화\n\n**_성과_**\n\n- 서비스 중단 80% 감소\n\n---\n\n## 하이텍앤솔\n\n2018.07 ~ 2021.10 `3년 3개월`\n\n수도 원격검침 시스템 임베디드 개발자로 근무하며 Legacy 개선에 기여했습니다.\n\n### Embedded Firmware\n\n연 10~20만대 양산되는 회사의 모든 임베디드 제품군(Texas Instrument MSP430) Firmware 유지보수\n\n**_기술_**\n\n- Ceedling, Makefile 기반 Unit Test 도입 Coverage(0 → 60%)\n- Doxygen,Gcov 기반 SW 문서화 도입\n- Silicon Errata 분석, 적용으로 MCU Hang 개선\n- Wireshark 패킷 분석을 통한 무선통신 에러 / 예외처리 개선\n- Peripheral Devices in Embedded Systems\n  - Serial Communication Interfaces (SCI) like UART, RS-485, I2C, SPI\n  - IoT Network Skill like NB-IoT, LoRa, ISM Band, TCP, UDP\n  - Timer, PLL, ADC Signal Analysis, JTAG Debugging, etc\n\n**_성과_**\n\n- 불량률 90% 감소\n\n### 초음파 수도 계량기 신규 개발\n\n국내에서 가장 정밀한 차세대 수도 계량기 개발, 알고리즘 특허 출원\n\n**_기술_**\n\n- 신규 MCU 선정, Bring-up, Firmware 개발\n- KC, KTC, GS, IP68 Certification\n- The Reynolds Number, In Fluid Mechanics, predict flow patterns\n- Correlation & Curve Fitting With Ultrasonic ADC Signal Processing\n\n**_성과_**\n\n- 유량 추측 알고리즘 개발 특허 출원 (등록번호: 1021166510000)\n  - 특허 기반 LG이노텍 연계 매출 발생\n- 국책 연구 개발 성공\n\n### 수도미터 생산 자동화 시스템 신규 개발\n\n생산성, 비용 감소를 위해 생산라인 자동화 설계, 개발\n\n**_기술_**\n\n- 자동화 시나리오 설계 PC App ↔ Data Terminal ↔ Meter\n- Modbus, RS-485 통신 기능 개발, 프로토콜 설계\n\n**_성과_**\n\n- 생산성 증가, 시스템 판매 매출 발생\n\n---\n\n# Other Experience.\n\n**특허 출원**\n\n2020.05.23\n\n- 초음파 유량 추측 알고리즘 특허\n- 등록 번호 : 1021166510000\n\n**SW 마에스트로**\n\n2012.07~2013.02\n\n- MPSoC[S5PV310] Custom Bootloader, RTOS 개발\n- 교육용 ARM로봇의 JAVA 플랫폼 JNI 개발\n\n**창의적 종합설계\n경진대회\n본선 특별상**\n\n2011.11\n\n- 가시광 통신 기반 실내위치 파악 시스템\n- Arm Cortex-A8 S5PV210, U-Boot, Android Gingerbread\n\n---\n\n# Skill.\n\n- Microcontroller : MSP430, ARM Cortex-A, Atmega128\n- Languege : Assembly, C, C++, Go, Python\n- Script : Shell, Bash, Makefile, Linker, Vim\n- Database : MySQL, Redis\n\n---\n\n# Education.\n\n울산대학교 전기전자공학과\n","fields":{"slug":"/about/"},"frontmatter":{"title":"About Me","subTitle":null,"date":null,"category":null,"cover":null}}},{"node":{"id":"a56eece8-cceb-59b0-ab1b-3a506284aba8","excerpt":"This page is a full functional test of mdx. Below is just about everything you’ll need to style in the theme. Check the source code to see…","rawBody":"---\ntitle: MDX full test\ncategory: test\ndate: 2020-09-17T12:40:07\n---\n\n# This page is a full functional test of mdx.\n\nBelow is just about everything you’ll need to style in the theme. Check the source code to see the many embedded elements within paragraphs.\n\n---\n\n# Heading 1 Test\n\n## Heading 2 Test\n\n### Heading 3 Test\n\n#### Heading 4 Test\n\n##### Heading 5 Test\n\n###### Heading 6 Test\n\n---\n\nLorem ipsum dolor sit amet adipiscing elit. **This is strong.** Nullam dignissim convallis est. Quisque aliquam. _This is emphasized._ Donec faucibus. Nunc iaculis suscipit dui. 5<sup>3</sup> = 125. Water is H<sub>2</sub>O. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. <cite>The New York Times</cite> (That’s a citation). <span style=\"text-decoration:underline;\">Underline</span>. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.\n\nHTML and CSS are our tools. Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. To copy a file type `COPY filename`. <del>Dinner’s at 5:00.</del> <span style=\"text-decoration:underline;\">Let’s make that 7</span>. This <del>text</del> has been struck.\n\n---\n\n## Media Test\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.\n\n### Big Image Test\n\n![Test Image](./preview.png)\n\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\n\n### Small Image Test\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore.\n\n![Small Test Image](./testimg2.jpg)\n\nLabore et dolore.\n\n---\n\n# Heading 1 Reset Test\n\n## List Types Test\n\n### Definition List Test\n\nDefinition List Title\n: This is a definition list division.\n\nDefinition\n: An exact statement or description of the nature, scope, or meaning of something: _our definition of what constitutes poetry._\n\n### Ordered List Test\n\n1. List Item 1\n2. List Item 2\n   1. Nested list item A\n   2. Nested list item B\n3. List Item 3\n\n### Unordered List Test\n\n- List Item 1\n- List Item 2\n  - Nested list item A\n  - Nested list item B\n- List Item 3\n\n---\n\n## Grid Table Test\n\n| Table Header 1 | Table Header 2 | Table Header 3 |\n| :------------: | :------------: | :------------: |\n|   Division 1   |   Division 2   |   Division 3   |\n|   Division 1   |   Division 2   |   Division 3   |\n|   Division 1   |   Division 2   |   Division 3   |\n\n---\n\n## Preformatted Text Test\n\nTypographically, preformatted text is not the same thing as code. Sometimes, a faithful execution of the text requires preformatted text that may not have anything to do with code. Most browsers use Courier and that’s a good default — with one slight adjustment, Courier 10 Pitch over regular Courier for Linux users.\n\n## Code Highlight Test\n\nCode can be presented inline, like `<?php bloginfo('stylesheet_url'); ?>` Because we have more specific typographic needs for code, we’ll specify Consolas and Monaco ahead of the browser-defined monospace font.\n\n### Title Test\n\nTo show the title, just add it to your code block. Ex: `title=src/myfile.css`\n\n```css title=src/myfile.css\n.gatsby::before {\n  content: 'niceee...';\n}\n```\n\n### Line numbers Test\n\nIf you want to show line number, just add a option `lineNumbers=true`.\n\n```js lineNumbers=true\nconst rocket = {\n  launch: () => console.log('Launching...'),\n};\n\nrocket.launch();\n```\n\n### Highlight Line Test\n\nIf you want to highlight lines, just add a option `{2, 4-5}`.\n\n```js lineNumbers=true {2,4-5}\nconst test = 3;\nconst foo = 'bar';\nconst harry = 'potter';\nconst hermione = 'granger';\nconst ron = 'weasley';\n```\n\n### React live Test\n\nAs mentioned in the introduction, this theme uses `react-live`, so you can\ncreate a playground for live editing React components.\n\nTo use it, just add a `live=true` option to your code block.\n\n```jsx live=true\nfunction MyComponent() {\n  function handleButtonClick() {\n    alert('wowww');\n  }\n\n  return <button onClick={handleButtonClick}>Hey, click me!</button>;\n}\n\nrender(<MyComponent />);\n```\n\n---\n\n## Blockquotes Test\n\nLet’s keep it simple. Italics are good to help set it off from the body text. Be sure to style the citation.\n\n> Good afternoon, gentlemen. I am a HAL 9000 computer. I became operational at the H.A.L. plant in Urbana, Illinois on the 12th of January 1992. My instructor was Mr. Langley, and he taught me to sing a song. If you’d like to hear it I can sing it for you. — [HAL 9000](http://en.wikipedia.org/wiki/HAL_9000)\n\nAnd here’s a bit of trailing text.\n\n---\n\n## Text-level semantics Test\n\nHTML elements\n\n<p>\n  The <a href=\"#\">a element</a> example <br />\n  The <abbr>abbr element</abbr> and <abbr title=\"Title text\">\n    abbr element with title\n  </abbr> examples <br />\n  The <b>b element</b> example <br />\n  The <cite>cite element</cite> example <br />\n  The <del>del element</del> example <br />\n  The <dfn>dfn element</dfn> and{\" \"}\n  <dfn title=\"Title text\">dfn element with title</dfn> examples <br />\n  The <em>em element</em> example <br />\n  The <i>i element</i> example <br />\n  The <ins>ins element</ins> example <br />\n  The <kbd>kbd element</kbd> example <br />\n  The <mark>mark element</mark> example <br />\n  The{\" \"}\n  <q>\n    q element <q>inside</q> a q element\n  </q>{\" \"}\n  example <br />\n  The <s>s element</s> example <br />\n  The <samp>samp element</samp> example <br />\n  The <small>small element</small> example <br />\n  The <span>span element</span> example <br />\n  The <strong>strong element</strong> example <br />\n  The <sub>sub element</sub> example <br />\n  The <sup>sup element</sup> example <br />\n  The <var>var element</var> example <br />\n  The <u>u element</u> example\n</p>\n* * *\n\n## Embeds Test\n\nSometimes all you want to do is embed a little love from another location and set your post alive.\n\n### Video Test\n\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\nCulpa qui officia deserunt mollit anim id est laborum.\n\n<iframe\n  src=\"//player.vimeo.com/video/103224792\"\n  width=\"600\"\n  height=\"337\"\n  frameborder=\"0\"\n  webkitallowfullscreen\n  mozallowfullscreen\n  allowfullscreen\n></iframe>\n\n### Slides Test\n\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\n<script\n  async\n  class=\"speakerdeck-embed\"\n  data-id=\"585245d01ee1013238737e42b879906f\"\n  data-ratio=\"1.77777777777778\"\n  src=\"//speakerdeck.com/assets/embed.js\"\n></script>\n\nCulpa qui officia deserunt mollit anim id est laborum.\n\n### Audio Test\n\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\n<iframe\n  width=\"100%\"\n  height=\"450\"\n  scrolling=\"no\"\n  frameborder=\"no\"\n  src=\"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/52891122&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true\"\n></iframe>\n\nCulpa qui officia deserunt mollit anim id est laborum.\n\n### Code Test\n\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt.\n\n<p\n  data-height=\"268\"\n  data-theme-id=\"0\"\n  data-slug-hash=\"bcqhe\"\n  data-default-tab=\"result\"\n  data-user=\"rglazebrook\"\n  class=\"codepen\"\n>\n  See the Pen{\" \"}\n  <a href=\"http://codepen.io/rglazebrook/pen/bcqhe/\">Simple Rotating Spinner</a>{\" \"}\n  by Rob Glazebrook (<a href=\"http://codepen.io/rglazebrook\">@rglazebrook</a>)\n  on <a href=\"http://codepen.io\">CodePen</a>.\n</p>\n<script async src=\"//assets.codepen.io/assets/embed/ei.js\"></script>\n\nIsn't it beautiful.\n\n_[HTML]: Hyper Text Markup Language\n_[CSS]: Cascading Style Sheets\n","fields":{"slug":"/test/mdxTest/"},"frontmatter":{"title":"MDX full test","subTitle":null,"date":"2020.09.17","category":"test","cover":null}}},{"node":{"id":"b30d6c3c-193a-59f0-9670-7b74fb9effe2","excerpt":"책 내용이 좋아 기록해 둔다. 비트 조작 최하위 비트 조작 i번째 비트와 j번째 비트를 Swap 비트 뒤집기 무식하게 해결하기  O(N) 무식하게 해결하기2  O(N) LUT 사용  O(N/L) N = 전체 비트수(32), L…","rawBody":"---\ntitle: 비트 조작(bit manipulation) 알고리즘\nsubTitle: from. Elements of Programming Interviews in C++\ncategory: algorithm\ndate: 2023-04-19T12:33:58\ncover:\n---\n\n책 내용이 좋아 기록해 둔다.\n\n# 비트 조작\n\n## 최하위 비트 조작\n\n```cpp\nint result = 0;\n// 최하위 비트 제거\nresult = x & (x - 1);\n// 최하위 비트 뽑기\nresult = x & ~(x - 1);\n```\n\n## i번째 비트와 j번째 비트를 Swap\n\n```cpp\nlong long SwapBits(long long x, int i, int j) {\n    // i,j 비트가 같다면 swap이 필요없음\n    if (((x >> i) & 1) == ((x >> j) & 1)) return x;\n\n    // 다르다면 i,j 비트를 XOR로 뒤집으면 스왑된다\n    unsigned long long bit_mask = (1L << i) || (1L << j);\n    return x & bit_mask;\n}\n```\n\n# 비트 뒤집기\n\n## 무식하게 해결하기 `O(N)`\n\n```cpp\ntemplate<std::size_t N>\nvoid reverse(std::bitset<N> &b) {\n    for(std::size_t i = 0; i < N/2; ++i) {\n        bool t = b[i];\n        b[i] = b[N-i-1];\n        b[N-i-1] = t;\n    }\n}\n```\n\n## 무식하게 해결하기2 `O(N)`\n\n```cpp\n#include <algorithm>\n#include <bitset>\n#include <iostream>\n#include <string>\n\nint main() {\n  auto x = std::bitset<32>(10);\n  std::cout << x << std::endl;\n\n  auto str = x.to_string();\n  std::reverse(str.begin(), str.end());\n  auto y = std::bitset<32>(str);\n  std::cout << y << std::endl;\n\n  return 0;\n}\n\n// result\n// 00000000000000000000000000001010\n// 01010000000000000000000000000000\n```\n\n## LUT 사용 `O(N/L)`\n\nN = 전체 비트수(32), L = 해시 테이블의 키값의 크기(8)\n\n```cpp\nstatic const unsigned char BitReverseTable256[256] = {\n#define R2(n) n, n + 2 * 64, n + 1 * 64, n + 3 * 64\n#define R4(n) R2(n), R2(n + 2 * 16), R2(n + 1 * 16), R2(n + 3 * 16)\n#define R6(n) R4(n), R4(n + 2 * 4), R4(n + 1 * 4), R4(n + 3 * 4)\n    R6(0), R6(2), R6(1), R6(3)};\n\nunsigned int v;  // reverse 32-bit value, 8 bits at time\nunsigned int c;  // c will get v reversed\n\n// Option 1:\nc = (BitReverseTable256[v & 0xff] << 24) |\n    (BitReverseTable256[(v >> 8) & 0xff] << 16) |\n    (BitReverseTable256[(v >> 16) & 0xff] << 8) |\n    (BitReverseTable256[(v >> 24) & 0xff]);\n\n// Option 2:\nunsigned char *p = (unsigned char *)&v;\nunsigned char *q = (unsigned char *)&c;\nq[3] = BitReverseTable256[p[0]];\nq[2] = BitReverseTable256[p[1]];\nq[1] = BitReverseTable256[p[2]];\nq[0] = BitReverseTable256[p[3]];\n```\n\n# Parity 계산하기\n\nParity를 구하는 알고리즘 비교.\n\n## 무식하게 풀기 `O(N)`\n\n```cpp\nshort Pairty(int x){\n    short result = 0;\n    while (x) {\n        result ^= (x & 1);\n        x >>= 1;\n    }\n    return result;\n}\n```\n\n## STL Bitset `O(N)`\n\n```cpp\nlong long value = 23423423;\ncout << (bitset<64>(value).count() & 1) << endl;\n```\n\n## 1로 세팅된 비트의 개수가 k개면 `O(k)`\n\n```cpp\nshort Parity(int x) {\n    short result = 0;\n    while (x) {\n        result ^= 1;\n        x &= (x - 1); // x의 하위비트 제거\n    }\n    return result;\n}\n```\n\n## LookUp Table을 이용한 방법 `O(N/L)`\n\nN = 전체 비트수(32), L = 해시 테이블의 키값의 크기(8)\n\n```cpp\n// Macros to generate the lookup table (at compile-time)\nstatic const bool ParityTable256[256] = {\n#define P2(n) n, n ^ 1, n ^ 1, n\n#define P4(n) P2(n), P2(n ^ 1), P2(n ^ 1), P2(n)\n#define P6(n) P4(n), P4(n ^ 1), P4(n ^ 1), P4(n)\n    P6(0), P6(1), P6(1), P6(0)};\n\n// Function to find parity of `x`\nshort findParity(int x) {\n    const short kMaskSize = 8;\n    const short kBitMask = 0xFF;\n\n    return ParityTable256[x >> (3 * kMaskSize)] ^\n           ParityTable256[(x >> (2 * kMaskSize)) & kBitMask] ^\n           ParityTable256[(x >> kMaskSize) & kBitMask] ^\n           ParityTable256[x & kBitMask];\n}\n```\n\n## 결합법칙, 교환법칙 응용 `O(logn)`\n\n```cpp\n// Compute parity of a number `x` using the lookup table\nshort findParity(int x) {\n    // recursively divide the (32–bit) integer into two equal\n    // halves and take their XOR until only 1 bit is left\n    x ^= x >> 16;\n    x ^= x >> 8;\n    x ^= x >> 4;\n    x ^= x >> 2;\n    x ^= x >> 1;\n\n    // return 1 if the last bit is set; otherwise, return 0\n    return x & 1;\n}\n```\n\n## Maybe... Best Practice\n\n```cpp\nstatic const bool ParityTable256[256] = {\n#define P2(n) n, n ^ 1, n ^ 1, n\n#define P4(n) P2(n), P2(n ^ 1), P2(n ^ 1), P2(n)\n#define P6(n) P4(n), P4(n ^ 1), P4(n ^ 1), P4(n)\n    P6(0), P6(1), P6(1), P6(0)};\n\nint main() {\n    // byte value to compute the parity of\n    unsigned char b;\n    bool parity = ParityTable256[b];\n\n    // OR, for 32-bit words:\n    unsigned int v;\n    v ^= v >> 16;\n    v ^= v >> 8;\n    parity = ParityTable256[v & 0xff];\n\n    // Variation:\n    unsigned char* p = (unsigned char*)&v;\n    parity = ParityTable256[p[0] ^ p[1] ^ p[2] ^ p[3]];\n    return 0;\n}\n```\n\n# Reference\n\nhttps://graphics.stanford.edu/~seander/bithacks.html\n","fields":{"slug":"/bit_algorithm/"},"frontmatter":{"title":"비트 조작(bit manipulation) 알고리즘","subTitle":"from. Elements of Programming Interviews in C++","date":"2023.04.19","category":"algorithm","cover":null}}}]}}}