{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/nordic_connect_sdk/bme68x/",
    "result": {"data":{"mdx":{"id":"f73849be-be12-59b6-8178-6d9a93b5133f","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"BME680 Device Driver Out-of-Tree\",\n  \"subTitle\": \"Zephyr v2.3.99, Nordic Connect SDK v2.4.2\",\n  \"category\": \"Zephyr RTOS, bme688, bme680\",\n  \"date\": \"2023-10-19T15:49:07.000Z\",\n  \"cover\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"BME680\\uC740 Zephyr-RTOS\\uC5D0\\uC11C \\uC9C0\\uC6D0\\uD55C\\uB2E4. \\uD558\\uC9C0\\uB9CC \\uC0AC\\uC6A9\\uD574\\uBCF4\\uB2C8 \\uC544\\uB798\\uC640 \\uAC19\\uC740 \\uBB38\\uC81C\\uC810\\uC774 \\uC788\\uC5B4 Driver\\uB97C \\uC785\\uB9DB\\uB300\\uB85C \\uB9CC\\uB4E4\\uC5B4 \\uBCF4\\uB824 \\uD55C\\uB2E4. nRF52832 \\uAE30\\uC900\\uC73C\\uB85C \\uC791\\uC131\\uB41C\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC81C\\uC791\\uD55C \\uCEE4\\uC2A4\\uD140 \\uBCF4\\uB4DC\\uC5D0\\uC11C BME680\\uC774 Load Switch\\uB85C \\uC81C\\uC5B4\\uB41C\\uB2E4.\\n\\uC2A4\\uC704\\uCE58\\uB294 gpio-hog \\uAE30\\uB2A5\\uC73C\\uB85C POST_KERNEL \\uD0C0\\uC774\\uBC0D\\uC5D0 output high\\uB85C \\uB418\\uC9C0\\uB9CC\\nZephyr\\uC5D0\\uC11C \\uAE30\\uBCF8\\uC73C\\uB85C \\uC9C0\\uC6D0\\uD558\\uB294 BME680\\uC758 Sensor Init\\uC774 \\uC2E4\\uD328\\uD55C\\uB2E4(I2C Read Device Fail)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BME680\\uC758 \\uAE30\\uBCF8 Sensor output\\uC740 \\uC628\\uB3C4,\\uAE30\\uC555,\\uC2B5\\uB3C4,\\uAC00\\uC2A4\\uB2E4. \\uD2B9\\uD788 \\uAC00\\uC2A4\\uB294 \\uC804\\uB825\\uC18C\\uBAA8\\uAC00 \\uD070\\uB370 \\uAE30\\uC874 Driver\\uB294 On/Off\\uB97C \\uC9C0\\uC6D0\\uD558\\uC9C0 \\uC54A\\uB294\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB610\\uD55C \\uAC00\\uC2A4\\uB370\\uC774\\uD130\\uB97C \\uAE30\\uBC18\\uC73C\\uB85C IAQ(Indoor Air Quility), VOC, CO2 \\uB4F1\\uC744 Bosch\\uC5D0\\uC11C \\uC9C0\\uC6D0\\uD558\\uB294 \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/boschsensortec/Bosch-BSEC2-Library\"\n  }, \"BSEC Library\"), \"\\uB85C \\uCD94\\uCD9C\\uD558\\uB294\\uB370 \\uC774\\uB294 \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.bosch-sensortec.com/media/boschsensortec/downloads/software/bme688_development_software/2023_04/license_terms_bme688_bme680_bsec.pdf\"\n  }, \"\\uB77C\\uC774\\uC13C\\uC2A4\"), \" \\uB54C\\uBB38\\uC778\\uC9C0 \\uD3EC\\uD568\\uB418\\uC5B4 \\uC788\\uC9C0 \\uC54A\\uB2E4.\")), mdx(\"p\", null, \"\\uB530\\uB77C\\uC11C \\uAE30\\uB2A5 \\uC694\\uAD6C\\uC0AC\\uD56D\\uC740 \\uB2E4\\uC74C\\uACFC \\uAC19\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BME680 Gas(IAQ, VOC, CO2) \\uCE21\\uC815 300Hz On/Off\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BME680 T,P,H \\uCE21\\uC815 3Hz\")), mdx(\"p\", null, \"\\uB4DC\\uB77C\\uC774\\uBC84 \\uCF54\\uB4DC\\uB294 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/bradkim06/bme68x_iaq_driver\"\n  }, \"bme68x_iaq_driver\"), \"\\uC5D0 \\uC788\\uB2E4.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"nrf connect sdk v2.5.0\\uC5D0\\uC11C \\uC9C0\\uC6D0\\uC774 \\uCD94\\uAC00\\uB418\\uB294 \\uAC83\\uC73C\\uB85C \\uBCF4\\uC774\\uC9C0\\uB9CC rc\\uBC84\\uC804\\uC774\\uB77C 2.4.2\\uBC84\\uC804\\uC744 \\uC720\\uC9C0\\uD558\\uACE0 \\uCC38\\uACE0\\uD558\\uC5EC \\uB530\\uB85C \\uB9CC\\uB4E0\\uB2E4. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/nrfconnect/sdk-nrf/tree/main/drivers/sensor/bme68x_iaq\"\n  }, \"BME680 IAQ Driver Code\"))), mdx(\"h1\", {\n    \"id\": \"device-driver-out-of-tree\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#device-driver-out-of-tree\",\n    \"aria-label\": \"device driver out of tree permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver Out-Of-Tree\"), mdx(\"p\", null, \"Driver\\uB294 Zephyr-RTOS\\uC5D0 PR\\uC744 \\uD560 \\uACC4\\uD68D\\uC774 \\uC5C6\\uC73C\\uBBC0\\uB85C Out of Tree\\uB85C \\uC791\\uC131\\uD55C\\uB2E4.\"), mdx(\"h2\", {\n    \"id\": \"buildcmake-kconfig\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#buildcmake-kconfig\",\n    \"aria-label\": \"buildcmake kconfig permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Build(CMake, Kconfig)\"), mdx(\"p\", null, \"Build\\uB97C \\uC704\\uD55C Basic \\uAD6C\\uC870\\uB294 \\uC544\\uB798\\uC640 \\uAC19\\uB2E4. Drivers \\uD3F4\\uB354\\uC640 library \\uD3F4\\uB354\\uAC00 \\uD544\\uC694\\uD558\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=Driver_Directory_Tree\",\n    \"title\": \"Driver_Directory_Tree\"\n  }, \".(Application Directory)\\n\\u251C\\u2500\\u2500 CMakeLists.txt //Drivers module \\uCD94\\uAC00 \\uD544\\uC694\\n\\u251C\\u2500\\u2500 Drivers\\n\\u2502   \\u251C\\u2500\\u2500 CMakeLists.txt\\n\\u2502   \\u251C\\u2500\\u2500 Kconfig\\n\\u2502   \\u251C\\u2500\\u2500 zephyr\\n\\u2502   \\u2502   \\u2514\\u2500\\u2500 module.yml\\n\\u2502   \\u2514\\u2500\\u2500 bme68x_iaq //bme680 driver\\n\\u2502       \\u2514\\u2500\\u2500 driver_files...\\n\\u251C\\u2500\\u2500 dts\\n\\u2502   \\u2514\\u2500\\u2500 bindings\\n\\u2502       \\u2514\\u2500\\u2500 bosch,bme68x-i2c.yaml\\n\\u2514\\u2500\\u2500 lib //bosch bsec Library\\n    \\u251C\\u2500\\u2500 bsec\\n    \\u2514\\u2500\\u2500 bme68x\\n\")), mdx(\"h3\", {\n    \"id\": \"driver-module-zephyr-build에-추가\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#driver-module-zephyr-build%EC%97%90-%EC%B6%94%EA%B0%80\",\n    \"aria-label\": \"driver module zephyr build에 추가 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Driver Module Zephyr Build\\uC5D0 \\uCD94\\uAC00\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zephyr/module.yml\"), \"\\uD30C\\uC77C\\uB85C out-of-tree \\uAD6C\\uC870\\uC758 \\uBAA8\\uB4C8\\uC744 \\uCD94\\uAC00\\uD560 \\uC218 \\uC788\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=Drivers/zephyr/module.yml\",\n    \"title\": \"Drivers/zephyr/module.yml\"\n  }, \"build:\\n  cmake: .\\n  kconfig: Kconfig\\n\")), mdx(\"p\", null, \"\\uBAA8\\uB4C8\\uC740 \\uC5B4\\uD50C\\uB9AC\\uCF00\\uC774\\uC158 \\uB8E8\\uD2B8\\uC758 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CMakeLists.txt\"), \"\\uC5D0\\uC11C \\uBE4C\\uB4DC \\uC2DC\\uC2A4\\uD15C\\uC5D0 \\uCD94\\uAC00\\uB41C\\uB2E4. zephyr package\\uB97C \\uBD88\\uB7EC\\uC624\\uAE30 \\uC804\\uC5D0 \\uCD94\\uAC00\\uD574\\uC57C \\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cmake\",\n    \"metastring\": \"title=CMakeLists.txt\",\n    \"title\": \"CMakeLists.txt\"\n  }, \"set(APP_ROOT ${CMAKE_SOURCE_DIR})\\nlist(APPEND ZEPHYR_EXTRA_MODULES\\n  ${APP_ROOT}/drivers\\n)\\nfind_package(Zephyr 3.3.99 EXACT)\\n\")), mdx(\"h3\", {\n    \"id\": \"kconfig\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#kconfig\",\n    \"aria-label\": \"kconfig permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Kconfig\"), mdx(\"p\", null, \"\\uBAA8\\uB4C8\\uC774 \\uCD94\\uAC00\\uB418\\uC5C8\\uC73C\\uBBC0\\uB85C Drivers \\uD3F4\\uB354\\uBD80\\uD130 Kconfig\\uB97C \\uC791\\uC131\\uD574 \\uB098\\uAC04\\uB2E4.\\nDrivers \\uD558\\uC704 \\uD3F4\\uB354(bme68x_iaq)\\uC5D0 \\uB4DC\\uB77C\\uC774\\uBC84 \\uCF54\\uB4DC\\uB4E4\\uC744 \\uAD6C\\uD604\\uD560 \\uC0DD\\uAC01\\uC774\\uBBC0\\uB85C \\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uB41C\\uB2E4.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uC791\\uC131\\uD558\\uB294 \\uBC29\\uBC95\\uC740 Zephyr\\uB098 Linux Document\\uC5D0 \\uC798 \\uC124\\uBA85\\uB418\\uC5B4 \\uC788\\uC73C\\uBBC0\\uB85C \\uCC38\\uACE0\\uD558\\uAE30 \\uBC14\\uB780\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=Drivers/Kconfig\",\n    \"title\": \"Drivers/Kconfig\"\n  }, \"rsource \\\"bme68x_iaq/Kconfig\\\"\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=Drivers/bme68x_iaq/Kconfig\",\n    \"title\": \"Drivers/bme68x_iaq/Kconfig\"\n  }, \"config BME68X\\n    bool \\\"BME68X sensor\\\"\\n    default n\\n    depends on DT_HAS_BOSCH_BME68X_ENABLED\\n    select I2C if $(dt_compat_on_bus,$(DT_COMPAT_BOSCH_BME68X),i2c)\\n    help\\n      Enable driver for BME68X I2C- or SPI- based temperature, pressure, humidity and gas sensor.\\n\\nconfig BME68X_IAQ\\n    bool \\\"Use Bosch BSEC library\\\"\\n    depends on SETTINGS && !SETTINGS_NONE\\n    depends on BME68X\\n    help\\n      Enable the use of Bosch BSEC library.\\n      This configuration depends on the BME680 Zephyr driver being disabled.\\n\\nif BME68X\\n\\nconfig BME68X_IAQ_SAVE_INTERVAL_MINUTES\\n    int \\\"Period in minutes after which BSEC state is saved to flash\\\"\\n    default 60\\n\\nconfig BME68X_IAQ_THREAD_STACK_SIZE\\n    int \\\"BSEC thread stack size\\\"\\n    default 4096\\n\\nconfig BME68X_IAQ_EXPECTED_AMBIENT_TEMP\\n    int \\\"Expected ambient temperature in C\\\"\\n    default 25\\n\\nconfig BME68X_IAQ_TEMPERATURE_OFFSET\\n    int \\\"BSEC temperature offset in centidegrees\\\"\\n    default 200\\n    help\\n      BSEC temperature offset. To account for external heat sources on the board.\\n      The actual value is divided by 100. This is due to the Kconfig parser\\n      not supporting floating point types.\\n      The default value 200 is translated to 2.0 degrees celsius offset.\\n\\nmodule = BME68X\\nmodule-str = BME68X\\nsource \\\"subsys/logging/Kconfig.template.log_config\\\"\\n\\nendif # BME68X\\n\")), mdx(\"h3\", {\n    \"id\": \"cmake\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#cmake\",\n    \"aria-label\": \"cmake permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"CMake\"), mdx(\"p\", null, \"Drivers\\uB294 \\uC2E4\\uC81C \\uB4DC\\uB77C\\uC774\\uBC84 \\uCF54\\uB4DC\\uAC00 \\uC5C6\\uC73C\\uBBC0\\uB85C Kconfig \\uC635\\uC158\\uC774 enable\\uB418\\uBA74 \\uD558\\uC704 \\uD3F4\\uB354\\uB97C \\uCD94\\uAC00\\uD558\\uB3C4\\uB85D \\uD55C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cmake\",\n    \"metastring\": \"title=Drivers/CMakeLists.txt\",\n    \"title\": \"Drivers/CMakeLists.txt\"\n  }, \"add_subdirectory_ifdef(CONFIG_BME68X bme68x_iaq)\\n\")), mdx(\"p\", null, \"\\uC2E4\\uC81C Driver \\uCF54\\uB4DC\\uB294 bosch\\uC758 \\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB97C \\uC0AC\\uC6A9\\uD558\\uBBC0\\uB85C build \\uC2DC\\uC2A4\\uD15C\\uC5D0 \\uC544\\uB798\\uC640 \\uAC19\\uC774 \\uCD94\\uAC00\\uD55C\\uB2E4.\\n\\uB77C\\uC774\\uBE0C\\uB7EC\\uB9AC\\uB294 \\uB450\\uAC00\\uC9C0\\uAC00 \\uD3EC\\uD568\\uB41C\\uB2E4. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/boschsensortec/Bosch-BME68x-Library\"\n  }, \"Bosch-BME68x-Library\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/boschsensortec/Bosch-BSEC2-Library\"\n  }, \"BSEC Library\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"nordic v2.5.0-rc1\\uACFC \\uCC28\\uC774\\uC810\\uC73C\\uB85C SAMPLE_RATE T,P,H\\uC640 Gas\\uB97C \\uAD6C\\uBD84\\uD558\\uACE0 Cortex-m33\\uB97C \\uC81C\\uAC70\\uD588\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cmake\",\n    \"metastring\": \"title=Drivers/bme68x_iaq/CMakeLists.txt\",\n    \"title\": \"Drivers/bme68x_iaq/CMakeLists.txt\"\n  }, \"zephyr_library()\\nzephyr_library_include_directories(${APP_ROOT}/lib/bsec/src/inc)\\nzephyr_library_include_directories(${APP_ROOT}/lib/bme68x/src/bme68x)\\nzephyr_library_sources(${APP_ROOT}/lib/bme68x/src/bme68x/bme68x.c)\\n\\nzephyr_library_compile_definitions(\\n  BSEC_SAMPLE_RATE=BSEC_SAMPLE_RATE_LP\\n  BSEC_SAMPLE_RATE_IAQ=BSEC_SAMPLE_RATE_ULP\\n  BSEC_SAMPLE_PERIOD_S=3\\n)\\n\\nif (CONFIG_FP_HARDABI)\\n  if (CONFIG_CPU_CORTEX_M4)\\n    zephyr_library_import(bsec_lib ${APP_ROOT}/lib/bsec/src/cortex-m4/fpv4-sp-d16-hard/libalgobsec.a)\\n  else()\\n    assert(0 \\\"Unsupported configuration.\\\")\\n  endif()\\nelse()\\n  zephyr_library_compile_definitions(BME68X_DO_NOT_USE_FPU)\\n  if (CONFIG_CPU_CORTEX_M4)\\n    zephyr_library_import(bsec_lib ${APP_ROOT}/lib/bsec/src/cortex-m4/libalgobsec.a)\\n  else()\\n    assert(0 \\\"Unsupported configuration.\\\")\\n  endif()\\nendif()\\n\\nzephyr_library_sources(bme68x_iaq.c)\\n\")), mdx(\"h2\", {\n    \"id\": \"devicd-tree-작성\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#devicd-tree-%EC%9E%91%EC%84%B1\",\n    \"aria-label\": \"devicd tree 작성 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Devicd Tree \\uC791\\uC131\"), mdx(\"h3\", {\n    \"id\": \"bindings\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#bindings\",\n    \"aria-label\": \"bindings permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"bindings\"), mdx(\"p\", null, \"ncs\\uB294 compatible\\uC744 bosch,bme680\\uC744 \\uC0AC\\uC6A9\\uD558\\uACE0 kernel\\uC758 CONFIG_BME680\\uC744 \\u201Cn\\u201D\\uC73C\\uB85C \\uC124\\uC815\\uD574\\uC57C \\uAC00\\uB2A5\\uD558\\uB2E4. \\uAD73\\uC774 \\uC774\\uB807\\uAC8C \\uD560 \\uD544\\uC694\\uAC00 \\uC788\\uB098 \\uC2F6\\uC5B4 compatible\\uC744 bosch,bme68x\\uB85C \\uC0C8\\uB85C \\uC0DD\\uC131\\uD55C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=dts/bindings/bosch,bme68x-i2c.yaml lineNumbers=true {5}\",\n    \"title\": \"dts/bindings/bosch,bme68x-i2c.yaml\",\n    \"lineNumbers\": \"true\",\n    \"{5}\": true\n  }, \"description: |\\n    The BME680 is an integrated environmental sensor that measures\\n    temperature, pressure, humidity and air quality\\n\\ncompatible: \\\"bosch,bme68x\\\"\\n\\ninclude: [sensor-device.yaml, i2c-device.yaml]\\n\")), mdx(\"h3\", {\n    \"id\": \"device-tree-script\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#device-tree-script\",\n    \"aria-label\": \"device tree script permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"device tree script\"), mdx(\"p\", null, \"device tree\\uB97C \\uC791\\uC131\\uD55C\\uB2E4. \\uB0B4 \\uACBD\\uC6B0\\uB294 Board\\uB3C4 Out of Tree\\uB85C \\uB418\\uC5B4\\uC788\\uC5B4\\uC11C \\uB2E4\\uC74C\\uACFC \\uAC19\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=boards/arm/hhs_nrf52832/hhs_nrf52832.dts lineNumbers=true {10-15}\",\n    \"title\": \"boards/arm/hhs_nrf52832/hhs_nrf52832.dts\",\n    \"lineNumbers\": \"true\",\n    \"{10-15}\": true\n  }, \"i2c: &i2c0 {\\n    compatible = \\\"nordic,nrf-twim\\\";\\n    status = \\\"okay\\\";\\n    clock-frequency = <I2C_BITRATE_FAST>;\\n\\n    pinctrl-0 = <&i2c0_default>;\\n    pinctrl-1 = <&i2c0_sleep>;\\n    pinctrl-names = \\\"default\\\", \\\"sleep\\\";\\n\\n    bme68x:bme68x@76 {\\n        compatible = \\\"bosch,bme68x\\\";\\n        status = \\\"okay\\\";\\n        friendly-name = \\\"bosch environment sensor\\\";\\n        reg = <0x76>;\\n    };\\n};\\n\")), mdx(\"h2\", {\n    \"id\": \"device-driver-code-작성\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#device-driver-code-%EC%9E%91%EC%84%B1\",\n    \"aria-label\": \"device driver code 작성 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver Code \\uC791\\uC131\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://bradkim06.github.io/nordic_connect_sdk/device_driver/\"\n  }, \"Zephyr RTOS Device Driver \\uBD84\\uC11D\"), \"\\uC5D0\\uC11C \\uBD24\\uB4EF\\uC774 \\uB4DC\\uB77C\\uC774\\uBC84 \\uCF54\\uB4DC\\uC758 \\uC791\\uC131\\uC774 \\uD544\\uC694\\uD558\\uB2E4. \\uB4DC\\uB77C\\uC774\\uBC84 \\uCF54\\uB4DC \\uAD6C\\uC870\\uC640 \\uC0C1\\uC138 \\uBD84\\uC11D\\uC740 \\uC0DD\\uB7B5\\uD55C\\uB2E4.\"), mdx(\"h3\", {\n    \"id\": \"sensor-channel-추가-header-file\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#sensor-channel-%EC%B6%94%EA%B0%80-header-file\",\n    \"aria-label\": \"sensor channel 추가 header file permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Sensor Channel \\uCD94\\uAC00 Header file\"), mdx(\"p\", null, \"Zephyr\\uC5D0 \\uC5C6\\uB294 SENSOR CHANNEL IAQ\\uB97C \\uCD94\\uAC00\\uB85C \\uC0DD\\uC131\\uD55C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\",\n    \"metastring\": \"title=include/drivers/bme68x_iaq.h\",\n    \"title\": \"include/drivers/bme68x_iaq.h\"\n  }, \"/*\\n * Copyright (c) 2023 Nordic Semiconductor ASA\\n *\\n * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause\\n */\\n\\n#ifndef _BME68X_NCS_H_\\n#define _BME68X_NCS_H_\\n\\n/**\\n * @file bme68x_iaq.h\\n *\\n * @brief Public API for the bme68x driver.\\n */\\n\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n#define SENSOR_CHAN_IAQ (SENSOR_CHAN_PRIV_START + 1)\\n\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n#endif /* _BME68X_NCS_H_ */\\n\")), mdx(\"h3\", {\n    \"id\": \"driver-header\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#driver-header\",\n    \"aria-label\": \"driver header permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Driver Header\"), mdx(\"p\", null, \"\\uAE30\\uC874 ncs driver \\uCF54\\uB4DC\\uC5D0\\uC11C IAQ accuracy, co2, voc\\uB97C \\uCD94\\uAC00\\uD588\\uB2E4 (line 21 ~ 29).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\",\n    \"metastring\": \"title=Drivers/bme68x_iaq/bme68x_iaq.h lineNumbers=true {21-29}\",\n    \"title\": \"Drivers/bme68x_iaq/bme68x_iaq.h\",\n    \"lineNumbers\": \"true\",\n    \"{21-29}\": true\n  }, \"/*\\n * Copyright (c) 2023 Nordic Semiconductor ASA\\n *\\n * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause\\n */\\n\\n/* NCS Integration for BME68X + BSEC */\\n\\n#include <zephyr/kernel.h>\\n#include \\\"bsec_interface.h\\\"\\n#include \\\"bme68x.h\\\"\\n#include <drivers/bme68x_iaq.h>\\n\\n#ifndef ZEPHYR_DRIVERS_SENSOR_BME68X_NCS\\n#define ZEPHYR_DRIVERS_SENSOR_BME68X_NCS\\n\\nstruct bme_sample_result {\\n    double temperature;\\n    double humidity;\\n    double pressure;\\n#if defined(CONFIG_BME68X_IAQ)\\n    // Indoor-air-quality (IAQ)\\n    /* arr[0] : iaq value, arr[1] : iaq accuracy */\\n    uint16_t air_quality[2];\\n    // Estimation of the CO2 level in ppm\\n    double eCO2;\\n    // Conversion into breath-VOC equivalents in ppm concentration\\n    double breathVOC;\\n#endif\\n};\\n\\nstruct bme68x_iaq_config {\\n    const struct i2c_dt_spec i2c;\\n};\\n\\nstruct bme68x_iaq_data {\\n    /* Variable to store intermediate sample result */\\n    struct bme_sample_result latest;\\n\\n    /* Trigger and corresponding handler */\\n    sensor_trigger_handler_t trg_handler;\\n    const struct sensor_trigger *trigger;\\n\\n    /* Internal BSEC thread metadata value. */\\n    struct k_thread thread;\\n\\n    /* Buffer used to maintain the BSEC library state. */\\n    uint8_t state_buffer[BSEC_MAX_STATE_BLOB_SIZE];\\n\\n    /* Size of the saved state */\\n    int32_t state_len;\\n\\n    bsec_sensor_configuration_t required_sensor_settings[BSEC_MAX_PHYSICAL_SENSOR];\\n    uint8_t n_required_sensor_settings;\\n\\n    /* some RAM space needed by bsec_get_state and bsec_set_state for (de-)serialization. */\\n    uint8_t work_buffer[BSEC_MAX_WORKBUFFER_SIZE];\\n\\n    bool initialized;\\n\\n    struct bme68x_dev dev;\\n};\\n\\n#endif /* ZEPHYR_DRIVERS_SENSOR_BME68X_NCS */\\n\")), mdx(\"h3\", {\n    \"id\": \"driver-code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#driver-code\",\n    \"aria-label\": \"driver code permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Driver Code\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"NCS Driver\\uC5D0\\uC11C \\uBCC0\\uACBD\\uC0AC\\uD56D\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"device compatible\\uC744 bosch,bme68x\\uB85C \\uBCC0\\uACBD\\uD588\\uB2E4. (line 22)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"CONFIG_BME68X_IAQ \\uC635\\uC158\\uC5D0 \\uB530\\uB77C iaq,voc,co2\\uB4F1\\uC758 gas\\uCE21\\uC815\\uC744 on/off\\uD55C\\uB2E4.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"line (30~34)(53~66)(168~183)(272~276)(518~527)\")))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\",\n    \"metastring\": \"title=Drivers/bme68x_iaq/bme68x_iaq.c lineNumbers=true {22,30-34,53-66,168-183,272-276,518-527}\",\n    \"title\": \"Drivers/bme68x_iaq/bme68x_iaq.c\",\n    \"lineNumbers\": \"true\",\n    \"{22,30-34,53-66,168-183,272-276,518-527}\": true\n  }, \"/*\\n * Copyright (c) 2023 Nordic Semiconductor ASA\\n *\\n * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause\\n */\\n\\n/* NCS Integration for BME68X + BSEC */\\n\\n#include <string.h>\\n#include <zephyr/kernel.h>\\n#include <zephyr/init.h>\\n#include <zephyr/settings/settings.h>\\n#include <zephyr/drivers/i2c.h>\\n#include <zephyr/drivers/sensor.h>\\n\\n#include \\\"bme68x_iaq.h\\\"\\n#include \\\"bsec_datatypes.h\\\"\\n\\n#include <zephyr/logging/log.h>\\nLOG_MODULE_REGISTER(bsec, CONFIG_BME68X_LOG_LEVEL);\\n\\n#define DT_DRV_COMPAT bosch_bme68x\\n\\n#define BSEC_TOTAL_HEAT_DUR      UINT16_C(140)\\n#define BSEC_INPUT_PRESENT(x, shift) (x.process_data & (1 << (shift - 1)))\\n\\n/* Temperature offset due to external heat sources. */\\nstatic const float temp_offset = (CONFIG_BME68X_IAQ_TEMPERATURE_OFFSET / (float)100);\\n\\n#if defined(CONFIG_BME68X_IAQ)\\n#define BSEC_N_OUTPUTS 6\\n#else\\n#define BSEC_N_OUTPUTS 3\\n#endif\\n\\n/* Define which sensor values to request.\\n * The order is not important, but output_ready needs to be updated if different types\\n * of sensor values are requested.\\n */\\nstatic const bsec_sensor_configuration_t bsec_requested_virtual_sensors[BSEC_N_OUTPUTS] = {\\n    {\\n        .sensor_id = BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE,\\n        .sample_rate = BSEC_SAMPLE_RATE,\\n    },\\n    {\\n        .sensor_id = BSEC_OUTPUT_RAW_PRESSURE,\\n        .sample_rate = BSEC_SAMPLE_RATE,\\n    },\\n    {\\n        .sensor_id = BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY,\\n        .sample_rate = BSEC_SAMPLE_RATE,\\n    },\\n#if defined(CONFIG_BME68X_IAQ)\\n    {\\n        .sensor_id = BSEC_OUTPUT_IAQ,\\n        .sample_rate = BSEC_SAMPLE_RATE_IAQ,\\n    },\\n    {\\n        .sensor_id = BSEC_OUTPUT_CO2_EQUIVALENT,\\n        .sample_rate = BSEC_SAMPLE_RATE_IAQ,\\n    },\\n    {\\n        .sensor_id = BSEC_OUTPUT_BREATH_VOC_EQUIVALENT,\\n        .sample_rate = BSEC_SAMPLE_RATE_IAQ,\\n    },\\n#endif\\n};\\n\\n/* Definitions used to store and retrieve BSEC state from the settings API */\\n#define SETTINGS_NAME_BSEC  \\\"bsec\\\"\\n#define SETTINGS_KEY_STATE  \\\"state\\\"\\n#define SETTINGS_BSEC_STATE SETTINGS_NAME_BSEC \\\"/\\\" SETTINGS_KEY_STATE\\n\\n/* Stack size of internal BSEC thread. */\\nstatic K_THREAD_STACK_DEFINE(thread_stack, CONFIG_BME68X_IAQ_THREAD_STACK_SIZE);\\n\\n/* Used for a timeout for when BSEC's state should be saved. */\\nstatic K_TIMER_DEFINE(bsec_save_state_timer, NULL, NULL);\\n\\n/* I2C spec for BME68x sensor */\\nstatic struct i2c_dt_spec bme68x_i2c_spec;\\n\\n/* Semaphore to make sure output data isn't read while being updated */\\nstatic K_SEM_DEFINE(output_sem, 1, 1);\\n\\nstatic int settings_load_handler(const char *key, size_t len, settings_read_cb read_cb,\\n                 void *cb_arg, void *param)\\n{\\n    ARG_UNUSED(key);\\n    struct bme68x_iaq_data *data = param;\\n\\n    if (len > ARRAY_SIZE(data->state_buffer)) {\\n        return -EINVAL;\\n    }\\n\\n    data->state_len = read_cb(cb_arg, data->state_buffer, len);\\n\\n    if (data->state_len > 0) {\\n        return 0;\\n    }\\n\\n    LOG_WRN(\\\"No settings data read\\\");\\n    return -ENODATA;\\n}\\n\\n/* Export current state of BSEC and save it to flash. */\\nstatic void state_save(const struct device *dev)\\n{\\n    int ret;\\n    struct bme68x_iaq_data *data = dev->data;\\n\\n    LOG_DBG(\\\"saving state to flash\\\");\\n\\n    ret = bsec_get_state(0, data->state_buffer, ARRAY_SIZE(data->state_buffer),\\n                 data->work_buffer, ARRAY_SIZE(data->work_buffer), &data->state_len);\\n\\n    __ASSERT(ret == BSEC_OK, \\\"bsec_get_state failed.\\\");\\n    __ASSERT(data->state_len <= sizeof(data->state_buffer), \\\"state buffer too big to save.\\\");\\n\\n    ret = settings_save_one(SETTINGS_BSEC_STATE, data->state_buffer, data->state_len);\\n\\n    __ASSERT(ret == 0, \\\"storing state to flash failed.\\\");\\n}\\n\\n/* I2C bus write forwarder for bme68x driver */\\nstatic int8_t bus_write(uint8_t reg_addr, const uint8_t *reg_data_ptr, uint32_t len, void *intf_ptr)\\n{\\n    uint8_t buf[len + 1];\\n\\n    buf[0] = reg_addr;\\n    memcpy(&buf[1], reg_data_ptr, len);\\n\\n    return i2c_write_dt(&bme68x_i2c_spec, buf, ARRAY_SIZE(buf));\\n}\\n\\n/* I2C bus read forwarder for bme68x driver */\\nstatic int8_t bus_read(uint8_t reg_addr, uint8_t *reg_data_ptr, uint32_t len, void *intf_ptr)\\n{\\n    return i2c_write_read_dt(&bme68x_i2c_spec, &reg_addr, 1, reg_data_ptr, len);\\n}\\n\\n/* delay function for bme68x driver */\\nstatic void delay_us(uint32_t period, void *intf_ptr)\\n{\\n    k_usleep((int32_t)period);\\n}\\n\\n/* function to handle output of BSEC */\\nstatic void output_ready(const struct device *dev, const bsec_output_t *outputs, uint8_t n_outputs)\\n{\\n    struct bme68x_iaq_data *data = dev->data;\\n\\n    k_sem_take(&output_sem, K_FOREVER);\\n    for (size_t i = 0; i < n_outputs; ++i) {\\n        switch (outputs[i].sensor_id) {\\n        case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE:\\n            data->latest.temperature = (double)outputs[i].signal;\\n            LOG_DBG(\\\"Temp: %.2f C\\\", data->latest.temperature);\\n            break;\\n        case BSEC_OUTPUT_RAW_PRESSURE:\\n            data->latest.pressure = (double)outputs[i].signal;\\n            LOG_DBG(\\\"Press: %.2f Pa\\\", data->latest.pressure);\\n            break;\\n        case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY:\\n            data->latest.humidity = (double)outputs[i].signal;\\n            LOG_DBG(\\\"Hum: %.2f %%\\\", data->latest.humidity);\\n            break;\\n#if defined(CONFIG_BME68X_IAQ)\\n        case BSEC_OUTPUT_IAQ:\\n            data->latest.air_quality[0] = (uint16_t)outputs[i].signal;\\n            data->latest.air_quality[1] = outputs[i].accuracy;\\n            LOG_DBG(\\\"IAQ: %d (accuracy %d)\\\", data->latest.air_quality[0],\\n                data->latest.air_quality[1]);\\n            break;\\n        case BSEC_OUTPUT_CO2_EQUIVALENT:\\n            data->latest.eCO2 = (uint16_t)outputs[i].signal;\\n            LOG_DBG(\\\"CO2 %d\\\", (uint16_t)outputs[i].signal);\\n            break;\\n        case BSEC_OUTPUT_BREATH_VOC_EQUIVALENT:\\n            data->latest.breathVOC = (uint16_t)outputs[i].signal;\\n            LOG_DBG(\\\"VOC %d\\\", (uint16_t)outputs[i].signal);\\n            break;\\n#endif\\n        default:\\n            LOG_WRN(\\\"unknown bsec output id: %d\\\", outputs[i].sensor_id);\\n            break;\\n        }\\n    }\\n    k_sem_give(&output_sem);\\n    if (data->trg_handler != NULL) {\\n        data->trg_handler(dev, data->trigger);\\n    }\\n}\\n\\n/* convert raw bme68x output to valid input for BSEC */\\nstatic size_t sensor_data_to_bsec_inputs(bsec_bme_settings_t sensor_settings,\\n                     const struct bme68x_data *data, bsec_input_t *inputs,\\n                     uint64_t timestamp_ns)\\n{\\n    size_t i = 0;\\n\\n    if (BSEC_INPUT_PRESENT(sensor_settings, BSEC_INPUT_TEMPERATURE)) {\\n        /* append heatsource input */\\n        inputs[i].sensor_id = BSEC_INPUT_HEATSOURCE;\\n        inputs[i].signal = temp_offset;\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Temp offset: %.2f\\\", inputs[i].signal);\\n        i++;\\n\\n        /* append temperature input */\\n        inputs[i].sensor_id = BSEC_INPUT_TEMPERATURE;\\n        inputs[i].signal = data->temperature;\\n\\n        if (IS_ENABLED(BME68X_DO_NOT_USE_FPU)) {\\n            /* in this config, temperature is output in centidegrees */\\n            inputs[i].signal /= 100.0f;\\n        }\\n\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Temp: %.2f\\\", inputs[i].signal);\\n        i++;\\n    }\\n    if (BSEC_INPUT_PRESENT(sensor_settings, BSEC_INPUT_HUMIDITY)) {\\n        inputs[i].sensor_id = BSEC_INPUT_HUMIDITY;\\n        inputs[i].signal = data->humidity;\\n\\n        if (IS_ENABLED(BME68X_DO_NOT_USE_FPU)) {\\n            /* in this config, humidity is output in millipercent */\\n            inputs[i].signal /= 1000.0f;\\n        }\\n\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Hum: %.2f\\\", inputs[i].signal);\\n        i++;\\n    }\\n    if (BSEC_INPUT_PRESENT(sensor_settings, BSEC_INPUT_PRESSURE)) {\\n        inputs[i].sensor_id = BSEC_INPUT_PRESSURE;\\n        inputs[i].signal = data->pressure;\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Press: %.2f\\\", inputs[i].signal);\\n        i++;\\n    }\\n    if (BSEC_INPUT_PRESENT(sensor_settings, BSEC_INPUT_GASRESISTOR)) {\\n        inputs[i].sensor_id = BSEC_INPUT_GASRESISTOR;\\n        inputs[i].signal = data->gas_resistance;\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Gas: %.2f\\\", inputs[i].signal);\\n        i++;\\n    }\\n    if (BSEC_INPUT_PRESENT(sensor_settings, BSEC_INPUT_PROFILE_PART)) {\\n        inputs[i].sensor_id = BSEC_INPUT_PROFILE_PART;\\n        if (sensor_settings.op_mode == BME68X_FORCED_MODE) {\\n            inputs[i].signal = 0;\\n        } else {\\n            inputs[i].signal = data->gas_index;\\n        }\\n        inputs[i].time_stamp = timestamp_ns;\\n        LOG_DBG(\\\"Profile: %.2f\\\", inputs[i].signal);\\n        i++;\\n    }\\n    return i;\\n}\\n\\n/* convert and apply bme68x settings chosen by BSEC */\\nstatic int apply_sensor_settings(const struct device *dev, bsec_bme_settings_t sensor_settings)\\n{\\n    int ret;\\n    struct bme68x_conf config = {0};\\n    struct bme68x_heatr_conf heater_config = {0};\\n    struct bme68x_iaq_data *data = dev->data;\\n\\n#if defined(CONFIG_BME68X_IAQ)\\n    heater_config.enable = BME68X_ENABLE;\\n#else\\n    heater_config.enable = BME68X_DISABLE;\\n#endif\\n    heater_config.heatr_temp = sensor_settings.heater_temperature;\\n    heater_config.heatr_dur = sensor_settings.heater_duration;\\n    heater_config.heatr_temp_prof = sensor_settings.heater_temperature_profile;\\n    heater_config.heatr_dur_prof = sensor_settings.heater_duration_profile;\\n    heater_config.profile_len = sensor_settings.heater_profile_len;\\n    heater_config.shared_heatr_dur = 0;\\n\\n    switch (sensor_settings.op_mode) {\\n    case BME68X_PARALLEL_MODE:\\n        /* this block is only executed for BME68X_PARALLEL_MODE */\\n        /* shared heating duration in milliseconds (converted from microseconds) */\\n        heater_config.shared_heatr_dur =\\n            BSEC_TOTAL_HEAT_DUR -\\n            (bme68x_get_meas_dur(sensor_settings.op_mode, &config, &data->dev) /\\n             INT64_C(1000));\\n\\n        __fallthrough;\\n    case BME68X_FORCED_MODE:\\n        /* this block is executed for any measurement mode */\\n        ret = bme68x_get_conf(&config, &data->dev);\\n        if (ret) {\\n            LOG_ERR(\\\"bme68x_get_conf err: %d\\\", ret);\\n            return ret;\\n        }\\n\\n        config.os_hum = sensor_settings.humidity_oversampling;\\n        config.os_temp = sensor_settings.temperature_oversampling;\\n        config.os_pres = sensor_settings.pressure_oversampling;\\n\\n        ret = bme68x_set_conf(&config, &data->dev);\\n        if (ret) {\\n            LOG_ERR(\\\"bme68x_set_conf err: %d\\\", ret);\\n            return ret;\\n        }\\n\\n        bme68x_set_heatr_conf(sensor_settings.op_mode, &heater_config, &data->dev);\\n\\n        __fallthrough;\\n    case BME68X_SLEEP_MODE:\\n        /* this block is executed for all modes */\\n        ret = bme68x_set_op_mode(sensor_settings.op_mode, &data->dev);\\n        if (ret) {\\n            LOG_ERR(\\\"bme68x_set_op_mode err: %d\\\", ret);\\n            return ret;\\n        }\\n        break;\\n    default:\\n        LOG_ERR(\\\"unknown op mode: %d\\\", sensor_settings.op_mode);\\n    }\\n    return 0;\\n}\\n\\nstatic void fetch_and_process_output(const struct device *dev, bsec_bme_settings_t *sensor_settings,\\n                     uint64_t timestamp_ns)\\n{\\n    uint8_t n_fields = 0;\\n    uint8_t n_outputs = 0;\\n    uint8_t n_inputs = 0;\\n    bsec_input_t inputs[BSEC_MAX_PHYSICAL_SENSOR] = {0};\\n    bsec_output_t outputs[ARRAY_SIZE(bsec_requested_virtual_sensors)] = {0};\\n    struct bme68x_data sensor_data[3] = {0};\\n    struct bme68x_iaq_data *data = dev->data;\\n    int ret = bme68x_get_data(sensor_settings->op_mode, sensor_data, &n_fields, &data->dev);\\n\\n    if (ret) {\\n        LOG_DBG(\\\"bme68x_get_data err: %d\\\", ret);\\n        return;\\n    }\\n\\n    for (size_t i = 0; i < n_fields; ++i) {\\n        n_outputs = ARRAY_SIZE(bsec_requested_virtual_sensors);\\n        n_inputs = sensor_data_to_bsec_inputs(*sensor_settings, sensor_data + i, inputs,\\n                              timestamp_ns);\\n\\n        if (n_inputs == 0) {\\n            continue;\\n        }\\n        ret = bsec_do_steps(inputs, n_inputs, outputs, &n_outputs);\\n        if (ret != BSEC_OK) {\\n            LOG_ERR(\\\"bsec_do_steps err: %d\\\", ret);\\n            continue;\\n        }\\n        output_ready(dev, outputs, n_outputs);\\n    }\\n}\\n\\n/* Manage all recurrings tasks for the sensor:\\n * - update device settings according to BSEC\\n * - fetch measurement values\\n * - update BSEC state\\n * - periodically save BSEC state to flash\\n */\\nstatic void bsec_thread_fn(const struct device *dev)\\n{\\n    int ret;\\n    bsec_bme_settings_t sensor_settings = {0};\\n\\n    while (true) {\\n        uint64_t timestamp_ns = k_ticks_to_ns_floor64(k_uptime_ticks());\\n\\n        if (timestamp_ns < sensor_settings.next_call) {\\n            LOG_DBG(\\\"bsec_sensor_control not ready yet\\\");\\n            k_sleep(K_NSEC(sensor_settings.next_call - timestamp_ns));\\n            continue;\\n        }\\n\\n        memset(&sensor_settings, 0, sizeof(sensor_settings));\\n        ret = bsec_sensor_control((int64_t)timestamp_ns, &sensor_settings);\\n        if (ret != BSEC_OK) {\\n            LOG_ERR(\\\"bsec_sensor_control err: %d\\\", ret);\\n            continue;\\n        }\\n\\n        if (apply_sensor_settings(dev, sensor_settings)) {\\n            continue;\\n        }\\n\\n        if (sensor_settings.trigger_measurement &&\\n            sensor_settings.op_mode != BME68X_SLEEP_MODE) {\\n            fetch_and_process_output(dev, &sensor_settings, timestamp_ns);\\n        }\\n\\n        /* if save timer is expired, save and restart timer */\\n        if (k_timer_remaining_get(&bsec_save_state_timer) == 0) {\\n            state_save(dev);\\n            k_timer_start(&bsec_save_state_timer,\\n                      K_MINUTES(CONFIG_BME68X_IAQ_SAVE_INTERVAL_MINUTES),\\n                      K_NO_WAIT);\\n        }\\n\\n        k_sleep(K_SECONDS(BSEC_SAMPLE_PERIOD_S));\\n    }\\n}\\n\\nstatic int bme68x_bsec_init(const struct device *dev)\\n{\\n    int err;\\n    struct bme68x_iaq_data *data = dev->data;\\n    const struct bme68x_iaq_config *config = dev->config;\\n\\n    bme68x_i2c_spec = config->i2c;\\n\\n    err = settings_subsys_init();\\n    if (err) {\\n        LOG_ERR(\\\"settings_subsys_init, error: %d\\\", err);\\n        return err;\\n    }\\n\\n    err = settings_load_subtree_direct(SETTINGS_BSEC_STATE, settings_load_handler, data);\\n    if (err) {\\n        LOG_ERR(\\\"settings_load_subtree, error: %d\\\", err);\\n        return err;\\n    }\\n\\n    if (!device_is_ready(bme68x_i2c_spec.bus)) {\\n        LOG_ERR(\\\"I2C device not ready\\\");\\n        return -ENODEV;\\n    }\\n\\n    data->dev.intf = BME68X_I2C_INTF;\\n    data->dev.intf_ptr = NULL;\\n    data->dev.read = bus_read;\\n    data->dev.write = bus_write;\\n    data->dev.delay_us = delay_us;\\n    data->dev.amb_temp = CONFIG_BME68X_IAQ_EXPECTED_AMBIENT_TEMP;\\n\\n    err = bme68x_init(&data->dev);\\n    if (err) {\\n        LOG_ERR(\\\"Failed to init bme68x: %d\\\", err);\\n        return err;\\n    }\\n\\n    err = bsec_init();\\n    if (err != BSEC_OK) {\\n        LOG_ERR(\\\"Failed to init BSEC: %d\\\", err);\\n        return err;\\n    }\\n\\n    err = bsec_set_state(data->state_buffer, data->state_len, data->work_buffer,\\n                 ARRAY_SIZE(data->work_buffer));\\n    if (err != BSEC_OK && err != BSEC_E_CONFIG_EMPTY) {\\n        LOG_ERR(\\\"Failed to set BSEC state: %d\\\", err);\\n    } else if (err == BSEC_OK) {\\n        LOG_DBG(\\\"Setting BSEC state successful.\\\");\\n    }\\n\\n    bsec_update_subscription(bsec_requested_virtual_sensors,\\n                 ARRAY_SIZE(bsec_requested_virtual_sensors),\\n                 data->required_sensor_settings, &data->n_required_sensor_settings);\\n\\n    k_thread_create(&data->thread, thread_stack, CONFIG_BME68X_IAQ_THREAD_STACK_SIZE,\\n            (k_thread_entry_t)bsec_thread_fn, (void *)dev, NULL, NULL,\\n            K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);\\n\\n    k_timer_start(&bsec_save_state_timer, K_MINUTES(CONFIG_BME68X_IAQ_SAVE_INTERVAL_MINUTES),\\n              K_NO_WAIT);\\n    return 0;\\n}\\n\\nstatic int bme68x_trigger_set(const struct device *dev, const struct sensor_trigger *trig,\\n                  sensor_trigger_handler_t handler)\\n{\\n    struct bme68x_iaq_data *data = dev->data;\\n\\n    if (trig->type != SENSOR_TRIG_TIMER) {\\n        LOG_ERR(\\\"Unsupported sensor channel\\\");\\n        return -ENOTSUP;\\n    }\\n\\n    if ((trig->chan == SENSOR_CHAN_ALL) || (trig->chan == SENSOR_CHAN_HUMIDITY) ||\\n        (trig->chan == SENSOR_CHAN_AMBIENT_TEMP) || (trig->chan == SENSOR_CHAN_PRESS) ||\\n        (trig->chan == SENSOR_CHAN_IAQ)) {\\n        data->trigger = trig;\\n        data->trg_handler = handler;\\n    } else {\\n        LOG_ERR(\\\"Unsupported sensor channel\\\");\\n        return -ENOTSUP;\\n    }\\n    return 0;\\n}\\n\\nstatic int bme68x_sample_fetch(const struct device *dev, enum sensor_channel chan)\\n{\\n    /* fetching is a requirement for the API */\\n    return 0;\\n}\\n\\nstatic int bme68x_channel_get(const struct device *dev, enum sensor_channel chan,\\n                  struct sensor_value *val)\\n{\\n    struct bme68x_iaq_data *data = dev->data;\\n    int result = 0;\\n\\n    k_sem_take(&output_sem, K_FOREVER);\\n    if (chan == SENSOR_CHAN_HUMIDITY) {\\n        sensor_value_from_double(val, data->latest.humidity);\\n    } else if (chan == SENSOR_CHAN_AMBIENT_TEMP) {\\n        sensor_value_from_double(val, data->latest.temperature);\\n    } else if (chan == SENSOR_CHAN_PRESS) {\\n        sensor_value_from_double(val, data->latest.pressure);\\n    }\\n#if defined(CONFIG_BME68X_IAQ)\\n    else if (chan == SENSOR_CHAN_IAQ) {\\n        val->val1 = data->latest.air_quality[0];\\n        val->val2 = data->latest.air_quality[1];\\n    } else if (chan == SENSOR_CHAN_CO2) {\\n        sensor_value_from_double(val, data->latest.eCO2);\\n    } else if (chan == SENSOR_CHAN_VOC) {\\n        sensor_value_from_double(val, data->latest.breathVOC);\\n    }\\n#endif\\n    else {\\n        LOG_ERR(\\\"Unsupported sensor channel\\\");\\n        result = -ENOTSUP;\\n    }\\n    k_sem_give(&output_sem);\\n    return result;\\n}\\n\\nstatic const struct sensor_driver_api bme68x_driver_api = {\\n    .sample_fetch = &bme68x_sample_fetch,\\n    .channel_get = &bme68x_channel_get,\\n    .trigger_set = bme68x_trigger_set,\\n};\\n\\n/* there can be only one device supported here because of BSECs internal state */\\nstatic struct bme68x_iaq_config config_0 = {\\n    .i2c = I2C_DT_SPEC_INST_GET(0),\\n};\\nstatic struct bme68x_iaq_data data_0;\\n\\nSENSOR_DEVICE_DT_INST_DEFINE(0, bme68x_bsec_init, NULL, &data_0, &config_0, POST_KERNEL,\\n                 CONFIG_SENSOR_INIT_PRIORITY, &bme68x_driver_api);\\n\")), mdx(\"h2\", {\n    \"id\": \"application-sample\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#application-sample\",\n    \"aria-label\": \"application sample permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Application Sample\"), mdx(\"h3\", {\n    \"id\": \"project-config\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#project-config\",\n    \"aria-label\": \"project config permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Project Config\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=prj.conf\",\n    \"title\": \"prj.conf\"\n  }, \"CONFIG_I2C=y\\nCONFIG_SENSOR=y\\nCONFIG_SENSOR_INFO=y\\n\\n# Temperature, Pressure, Humidity\\nCONFIG_BME68X=y\\n# Gas Mode(IAQ, CO2, VOC)\\nCONFIG_BME68X_IAQ=y\\n\\n# Settings - Used to store real-time device configuration to flash.\\nCONFIG_SETTINGS=y\\nCONFIG_SETTINGS_FCB=y\\nCONFIG_FCB=y\\nCONFIG_FLASH=y\\nCONFIG_FLASH_PAGE_LAYOUT=y\\nCONFIG_FLASH_MAP=y\\nCONFIG_STREAM_FLASH=y\\nCONFIG_MPU_ALLOW_FLASH_WRITE=y\\n\\nCONFIG_NEWLIB_LIBC=y\\nCONFIG_NEWLIB_LIBC_FLOAT_SCANF=y\\n\\nCONFIG_LOG=y\\nCONFIG_CONSOLE=y\\n\\nCONFIG_ASSERT=y\\nCONFIG_REBOOT=y\\nCONFIG_FPU=y\\n\")), mdx(\"h3\", {\n    \"id\": \"application-code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#application-code\",\n    \"aria-label\": \"application code permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Application Code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\",\n    \"metastring\": \"title=src/bme680_app.h\",\n    \"title\": \"src/bme680_app.h\"\n  }, \"#ifndef __APP_BME680_H__\\n#define __APP_BME680_H__\\n\\n#include <zephyr/drivers/sensor.h>\\n\\n#if defined(CONFIG_BME68X)\\nstruct bme680_data {\\n    struct sensor_value temp;\\n    struct sensor_value press;\\n    struct sensor_value humidity;\\n#if defined(CONFIG_BME68X_IAQ)\\n    struct sensor_value iaq;\\n    struct sensor_value eCO2;\\n    struct sensor_value breathVOC;\\n#endif\\n};\\n\\nextern struct bme680_data bme680;\\n\\n#endif\\n#endif\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\",\n    \"metastring\": \"title=src/bme680_app.c\",\n    \"title\": \"src/bme680_app.c\"\n  }, \"/**\\n * @file bme680.c\\n * @brief\\n * @author bradkim06\\n * @version v0.01\\n * @date 2023-09-18\\n */\\n#include <zephyr/kernel.h>\\n#include <zephyr/logging/log.h>\\n\\n#include <drivers/bme68x_iaq.h>\\n\\n#include \\\"bme680_app.h\\\"\\n\\n#if defined(CONFIG_BME68X)\\nLOG_MODULE_REGISTER(bme680, CONFIG_APP_LOG_LEVEL);\\n\\nconst struct sensor_trigger trig = {\\n    .chan = SENSOR_CHAN_ALL,\\n    .type = SENSOR_TRIG_TIMER,\\n};\\n\\nstruct bme680_data bme680;\\n\\nstatic void trigger_handler(const struct device *dev, const struct sensor_trigger *trig)\\n{\\n    // sensor_sample_fetch(dev);\\n    sensor_channel_get(dev, SENSOR_CHAN_AMBIENT_TEMP, &bme680.temp);\\n    sensor_channel_get(dev, SENSOR_CHAN_PRESS, &bme680.press);\\n    sensor_channel_get(dev, SENSOR_CHAN_HUMIDITY, &bme680.humidity);\\n#if defined(CONFIG_BME68X_IAQ)\\n    sensor_channel_get(dev, SENSOR_CHAN_IAQ, &bme680.iaq);\\n    sensor_channel_get(dev, SENSOR_CHAN_IAQ, &bme680.eCO2);\\n#endif\\n\\n    LOG_DBG(\\\"temp: %d.%06d\\xB0C; press: %d.%06dPa; humidity: %d.%06d%%\\\", bme680.temp.val1,\\n        bme680.temp.val2, bme680.press.val1, bme680.press.val2, bme680.humidity.val1,\\n        bme680.humidity.val2);\\n#if defined(CONFIG_BME68X_IAQ)\\n    LOG_DBG(\\\"iaq: %d(acc:%d); CO2: %dppm VOC: %dppm\\\", bme680.iaq.val1, bme680.iaq.val2,\\n        bme680.eCO2.val1, bme680.breathVOC.val1);\\n#endif\\n};\\n\\nint bme680_mon(void)\\n{\\n    const struct device *const dev = DEVICE_DT_GET_ANY(bosch_bme68x);\\n    if (!device_is_ready(dev)) {\\n        LOG_ERR(\\\"device is not ready\\\");\\n        return 0;\\n    }\\n\\n    k_sleep(K_SECONDS(2));\\n\\n    int ret = sensor_trigger_set(dev, &trig, trigger_handler);\\n    if (ret) {\\n        LOG_ERR(\\\"couldn't set trigger\\\");\\n        return 0;\\n    }\\n    return 0;\\n}\\n\\n/* size of stack area used by each thread */\\n#define STACKSIZE 1024\\n/* scheduling priority used by each thread */\\n#define PRIORITY  7\\nK_THREAD_DEFINE(bme680_id, STACKSIZE, bme680_mon, NULL, NULL, NULL, PRIORITY, 0, 0);\\n#endif\\n\")), mdx(\"h3\", {\n    \"id\": \"test-result\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#test-result\",\n    \"aria-label\": \"test result permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Test Result\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"SAMPLE_RATE\\uB294 \\uC804\\uCCB4 3\\uCD08\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"BSEC_SAMPLE_PERIOD_S=3\\uC73C\\uB85C 3\\uCD08\\uB9C8\\uB2E4 trigger \\uB428\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\",\n    \"metastring\": \"title=testLog\",\n    \"title\": \"testLog\"\n  }, \"[00:17:16.747,589] <dbg> bme680: temp: 23.842784\\xB0C; press: 101337.015625Pa; humidity: 45.609584%\\n[00:17:16.747,619] <dbg> bme680: iaq: 53(acc:1); CO2: 53ppm VOC: 0ppm\\n[00:17:19.752,044] <dbg> bme680: temp: 23.840270\\xB0C; press: 101335.593750Pa; humidity: 45.326335%\\n[00:17:19.752,075] <dbg> bme680: iaq: 49(acc:1); CO2: 49ppm VOC: 0ppm\\n[00:17:22.756,530] <dbg> bme680: temp: 23.835243\\xB0C; press: 101336.117187Pa; humidity: 45.259017%\\n[00:17:22.756,561] <dbg> bme680: iaq: 47(acc:1); CO2: 47ppm VOC: 0ppm\\n[00:17:25.760,986] <dbg> bme680: temp: 23.837755\\xB0C; press: 101336.179687Pa; humidity: 45.379238%\\n[00:17:25.761,016] <dbg> bme680: iaq: 46(acc:1); CO2: 46ppm VOC: 0ppm\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"BME680은 Zephyr-RTOS에서 지원한다. 하지만 사용해보니 아래와 같은 문제점이 있어 Driver를 입맛대로 만들어 보려 한다. nRF52832 기준으로 작성된다. 제작한 커스텀 보드에서 BME680이 Load Switch…","tableOfContents":{"items":[{"url":"#device-driver-out-of-tree","title":"Device Driver Out-Of-Tree","items":[{"url":"#buildcmake-kconfig","title":"Build(CMake, Kconfig)","items":[{"url":"#driver-module-zephyr-build에-추가","title":"Driver Module Zephyr Build에 추가"},{"url":"#kconfig","title":"Kconfig"},{"url":"#cmake","title":"CMake"}]},{"url":"#devicd-tree-작성","title":"Devicd Tree 작성","items":[{"url":"#bindings","title":"bindings"},{"url":"#device-tree-script","title":"device tree script"}]},{"url":"#device-driver-code-작성","title":"Device Driver Code 작성","items":[{"url":"#sensor-channel-추가-header-file","title":"Sensor Channel 추가 Header file"},{"url":"#driver-header","title":"Driver Header"},{"url":"#driver-code","title":"Driver Code"}]},{"url":"#application-sample","title":"Application Sample","items":[{"url":"#project-config","title":"Project Config"},{"url":"#application-code","title":"Application Code"},{"url":"#test-result","title":"Test Result"}]}]}]},"fields":{"slug":"/nordic_connect_sdk/bme68x/"},"frontmatter":{"title":"BME680 Device Driver Out-of-Tree","subTitle":"Zephyr v2.3.99, Nordic Connect SDK v2.4.2","date":"Thursday, October 19th 2023, 3:49  PM","cover":null}}},"pageContext":{"id":"f73849be-be12-59b6-8178-6d9a93b5133f"}},
    "staticQueryHashes": ["1265008906","2270979341","3868834917"]}