{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/nordic_connect_sdk/device_driver/Execution/",
    "result": {"data":{"mdx":{"id":"0a687588-494f-515a-ac91-4a43c2dbdf43","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Device Driver analysis (1), Execution\",\n  \"subTitle\": \"Zephyr RTOS Device Driver 분석\",\n  \"category\": \"Nordic Connect SDK\",\n  \"date\": \"2023-09-26T14:56:00.000Z\",\n  \"cover\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"device-driver-analysis-1-execution\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#device-driver-analysis-1-execution\",\n    \"aria-label\": \"device driver analysis 1 execution permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver analysis (1), Execution\"), mdx(\"p\", null, \"\\uC81C\\uC870\\uC0AC \\uBCC4\\uB85C Device Driver\\uB97C \\uC791\\uC131 \\uD558\\uC5EC Zephyr API\\uAD6C\\uC870\\uC5D0 \\uB9DE\\uCD98\\uB2E4. \\uB530\\uB77C\\uC11C User\\uB294 Device Driver\\uAC00 \\uC874\\uC7AC\\uD55C\\uB2E4\\uBA74 \\uAD6C\\uD604\\uC5D0 \\uC2E0\\uACBD\\uC4F0\\uC9C0 \\uC54A\\uACE0 \\uD45C\\uC900\\uD0C0\\uC785\\uC758 API\\uB9CC \\uC798 \\uC368\\uB3C4 \\uB300\\uBD80\\uBD84\\uC758 App\\uAC1C\\uBC1C\\uC774 \\uAC00\\uB2A5\\uD558\\uB2E4.\"), mdx(\"p\", null, \"\\uD558\\uC9C0\\uB9CC \\uAC1C\\uBCC4 \\uBCF4\\uB4DC\\uB97C \\uC81C\\uC791\\uD558\\uACE0 \\uC13C\\uC11C\\uB97C \\uC0AC\\uC6A9\\uD560 \\uACBD\\uC6B0 Device Driver\\uB97C \\uC791\\uC131\\uD574\\uC57C\\uD560 \\uD544\\uC694\\uAC00 \\uCD94\\uD6C4 \\uC788\\uC73C\\uBBC0\\uB85C \\uBD84\\uC11D\\uD574\\uBCF8\\uB2E4. NCS(Nordic Connect SDK v2.4.2)\\uAE30\\uC900.\"), mdx(\"h2\", {\n    \"id\": \"디바이스-드라이버-분석\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84-%EB%B6%84%EC%84%9D\",\n    \"aria-label\": \"디바이스 드라이버 분석 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"\\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84 \\uBD84\\uC11D\"), mdx(\"p\", null, \"Zephyr \\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84\\uC758 \\uD750\\uB984\\uC740 \\uB2E4\\uC74C\\uACFC \\uAC19\\uB2E4.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"781px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"138.5%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,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')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Figure1\",\n    \"title\": \"Figure1\",\n    \"src\": \"/static/7712d6a14e5838bc08c27b7560db3eb9/f4c47/Untitled.png\",\n    \"srcSet\": [\"/static/7712d6a14e5838bc08c27b7560db3eb9/f8f3a/Untitled.png 200w\", \"/static/7712d6a14e5838bc08c27b7560db3eb9/6a8a8/Untitled.png 400w\", \"/static/7712d6a14e5838bc08c27b7560db3eb9/f4c47/Untitled.png 781w\"],\n    \"sizes\": \"(max-width: 781px) 100vw, 781px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"auto\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"p\", null, \"Figure1\"), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uAC04\\uB2E8\\uD55C GPIO \\uC0AC\\uC6A9\\uBC95 \\uC608\\uC81C(blinky)\\uB97C \\uBCF8\\uB2E4.\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.zephyrproject.org/latest/build/dts/index.html\"\n  }, \"device_tree\"), \" \\uC124\\uBA85\\uC740 \\uC0DD\\uB7B5\\uD55C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// zephyr/include/zephyr/drivers/gpio.h\\n\\n#include <zephyr/kernel.h>\\n#include <zephyr/drivers/gpio.h>\\n\\n/* 1000 msec = 1 sec */\\n#define SLEEP_TIME_MS   1000\\n\\n/* The devicetree node identifier for the \\\"led0\\\" alias. */\\n#define LED0_NODE DT_ALIAS(led0)\\n\\n/*\\n * A build error on this line means your board is unsupported.\\n * See the sample documentation for information on how to fix this.\\n */\\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\\n\\nint main(void)\\n{\\n    int ret;\\n\\n    if (!gpio_is_ready_dt(&led)) {\\n        return 0;\\n    }\\n\\n    ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);\\n    if (ret < 0) {\\n        return 0;\\n    }\\n\\n    while (1) {\\n        ret = gpio_pin_toggle_dt(&led);\\n        if (ret < 0) {\\n            return 0;\\n        }\\n        k_msleep(SLEEP_TIME_MS);\\n    }\\n    return 0;\\n}\\n\")), mdx(\"p\", null, \"\\uD574\\uB2F9 \\uC608\\uC81C\\uC758 gpio \\uAD00\\uB828 api (gpio_dt_spec, gpio_is_ready_dt, gpio_pin_configure_dt, gpio_pin_toggle_dt)\\uB294 \\uBAA8\\uB450 zephyr/include/drivers/gpio.h \\uC5D0\\uC11C \\uC120\\uC5B8\\uC774 \\uB418\\uC5B4 \\uC788\\uB2E4. gpio_pin_toggle_dt \\uCF54\\uB4DC\\uB97C \\uBCF4\\uBA74 \\uC544\\uB798\\uC640 \\uAC19\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// zephyr/include/zephyr/drivers/gpio.h\\n\\n/**\\n * @brief Toggle pin level.\\n *\\n * @param port Pointer to the device structure for the driver instance.\\n * @param pin Pin number.\\n *\\n * @retval 0 If successful.\\n * @retval -EIO I/O error when accessing an external GPIO chip.\\n * @retval -EWOULDBLOCK if operation would block.\\n */\\nstatic inline int gpio_pin_toggle(const struct device *port, gpio_pin_t pin)\\n{\\n// assert\\uB9CC\\uC744 \\uC704\\uD55C \\uBCC0\\uC218\\uB85C __unused() = __attribute__((__unused__))\\uB85C \\uCEF4\\uD30C\\uC77C \\uACBD\\uACE0 \\uC81C\\uAC70\\n    __unused const struct gpio_driver_config *const cfg =\\n        (const struct gpio_driver_config *)port->config;\\n\\n// zephyr\\uC758 device driver Error handling \\uADDC\\uCE59\\uC5D0 \\uB530\\uB77C Assert\\uB85C \\uC608\\uBC29\\n\\n// In general, it\\u2019s best to use __ASSERT() macros instead of propagating return values unless the failure is expected to occur during the normal course of operation (such as a storage device full).\\n// \\uC77C\\uBC18\\uC801\\uC73C\\uB85C, \\uC2E4\\uD328\\uAC00 \\uC815\\uC0C1 \\uC791\\uC5C5 \\uC911\\uC5D0 \\uBC1C\\uC0DD\\uD560 \\uAC83\\uC73C\\uB85C \\uC608\\uC0C1\\uB418\\uC9C0 \\uC54A\\uB294 \\uD55C \\uBC18\\uD658 \\uAC12\\uC744 \\uC804\\uB2EC\\uD558\\uB294 \\uB300\\uC2E0 __ASSERT() \\uB9E4\\uD06C\\uB85C\\uB97C \\uC0AC\\uC6A9\\uD558\\uB294 \\uAC83\\uC774 \\uC88B\\uC2B5\\uB2C8\\uB2E4 (\\uC608: \\uC800\\uC7A5 \\uC7A5\\uCE58\\uAC00 \\uAC00\\uB4DD \\uCC2C \\uACBD\\uC6B0\\uC640 \\uAC19\\uC774).\\n// Bad parameters, programming errors, consistency checks, pathological/unrecoverable failures, etc., should be handled by assertions.\\n// \\uC798\\uBABB\\uB41C \\uB9E4\\uAC1C\\uBCC0\\uC218, \\uD504\\uB85C\\uADF8\\uB798\\uBC0D \\uC624\\uB958, \\uC77C\\uAD00\\uC131 \\uAC80\\uC0AC, \\uBCD1\\uD589 \\uBD88\\uAC00\\uB2A5\\uD55C \\uC2E4\\uD328 \\uB4F1\\uC740 \\uC5B4\\uC11C\\uC158(assertion)\\uC73C\\uB85C \\uCC98\\uB9AC\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\\n    __ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,\\n         \\\"Unsupported pin\\\");\\n\\n    return gpio_port_toggle_bits(port, (gpio_port_pins_t)BIT(pin));\\n}\\n\\n/**\\n * @brief Toggle pin level from a @p gpio_dt_spec.\\n *\\n * This is equivalent to:\\n *\\n *     gpio_pin_toggle(spec->port, spec->pin);\\n *\\n * @param spec GPIO specification from devicetree\\n * @return a value from gpio_pin_toggle()\\n */\\nstatic inline int gpio_pin_toggle_dt(const struct gpio_dt_spec *spec)\\n{\\n    return gpio_pin_toggle(spec->port, spec->pin);\\n}\\n\")), mdx(\"p\", null, \"\\uCD5C\\uC885\\uC801\\uC73C\\uB85C gpio_port_toggle_bits\\uB97C \\uC2E4\\uD589\\uD558\\uB294\\uB370 \\uB354 \\uB530\\uB77C\\uAC00\\uBCF4\\uBA74 \\uC544\\uB798\\uC640 \\uAC19\\uB2E4. Figure1\\uC758 \\uADF8\\uB9BC\\uC744 \\uCC38\\uACE0\\uD558\\uBA74 Generic\\uD55C Device Driver API \\uAD6C\\uD604\\uC744 \\uC704\\uD574 \\uCD94\\uC0C1\\uD654\\uAC00 \\uB418\\uC5B4 \\uC788\\uB2E4. \\uACB0\\uACFC\\uC801\\uC73C\\uB85C \\uC2E4\\uD589\\uB418\\uB294 \\uD568\\uC218\\uB294 z_impl_gpio_port_toggle_bits\\uB77C\\uACE0 \\uBCFC\\uC218 \\uC788\\uB2E4.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uC774\\uC804\\uACFC\\uB294 \\uB2E4\\uB974\\uAC8C zephyr/include/generated/syscall/gpio.h \\uC704\\uCE58\\uD55C \\uD30C\\uC77C\\uC778\\uB370 z_impl \\uBA85\\uBA85\\uADDC\\uCE59\\uC73C\\uB85C \\uB418\\uC5B4\\uC788\\uB294 \\uAD6C\\uD604\\uD568\\uC218\\uAC00 \\uC874\\uC7AC\\uD55C\\uB2E4. \\uC544\\uB798\\uC640 \\uAC19\\uC740 \\uC124\\uBA85\\uC774 \\uB418\\uC5B4\\uC788\\uB2E4.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uAD6C\\uD604 \\uAE30\\uB2A5\\uC740 \\uC2E4\\uC81C\\uB85C API \\uC791\\uC5C5\\uC744 \\uC218\\uD589\\uD558\\uB294 \\uAC83\\uC785\\uB2C8\\uB2E4.\\xA0Zephyr\\uB294 \\uC77C\\uBC18\\uC801\\uC73C\\uB85C \\uC778\\uC218\\uC5D0 \\uB300\\uD55C \\uC624\\uB958 \\uAC80\\uC0AC\\uB97C \\uAC70\\uC758 \\uB610\\uB294 \\uC804\\uD600 \\uC218\\uD589\\uD558\\uC9C0 \\uC54A\\uAC70\\uB098 \\uC5B4\\uC124\\uC158\\uC5D0 \\uB300\\uD574 \\uC774\\uB7EC\\uD55C \\uC885\\uB958\\uC758 \\uAC80\\uC0AC\\uB97C \\uC218\\uD589\\uD569\\uB2C8\\uB2E4.\\xA0\\uAD6C\\uD604 \\uD568\\uC218\\uB97C \\uC791\\uC131\\uD560 \\uB54C \\uB9E4\\uAC1C\\uBCC0\\uC218\\uC758 \\uC720\\uD6A8\\uC131 \\uAC80\\uC99D\\uC740 \\uC120\\uD0DD\\uC0AC\\uD56D\\uC774\\uBA70 \\uC5B4\\uC124\\uC158\\uC744 \\uD1B5\\uD574 \\uC218\\uD589\\uB418\\uC5B4\\uC57C \\uD569\\uB2C8\\uB2E4.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uBAA8\\uB4E0 \\uAD6C\\uD604 \\uD568\\uC218\\uB294 \\uC811\\uB450\\uC0AC\\uAC00 \\uBD99\\uC740 API \\uC774\\uB984\\uC778 \\uBA85\\uBA85 \\uADDC\\uCE59\\uC744 \\uB530\\uB77C\\uC57C \\uD569\\uB2C8\\uB2E4\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"z_impl_\"), \".\\xA0\\uAD6C\\uD604 \\uD568\\uC218\\uB294 API\\uC640 \\uB3D9\\uC77C\\uD55C \\uD5E4\\uB354\\uC5D0\\uC11C \\uC815\\uC801 \\uC778\\uB77C\\uC778 \\uD568\\uC218\\uB85C \\uC120\\uC5B8\\uB418\\uAC70\\uB098 \\uC77C\\uBD80 C \\uD30C\\uC77C\\uC5D0\\uC11C \\uC120\\uC5B8\\uB420 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\\xA0\\uAD6C\\uD604 \\uAE30\\uB2A5\\uC5D0\\uB294 \\uD504\\uB85C\\uD1A0\\uD0C0\\uC785\\uC774 \\uD544\\uC694\\uD558\\uC9C0 \\uC54A\\uC73C\\uBA70 \\uC790\\uB3D9\\uC73C\\uB85C \\uC0DD\\uC131\\uB429\\uB2C8\\uB2E4.\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"800px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"46.5%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5UlEQVQoz2WQu24TURCGT+Qqr0BBgUQKJCoKXoIHSEqKVIBQgqyIylwSmS5ciggERVyAKBCIoBCZwgqQxN6Ntb5jb+zE6735thfvOXuzz55BdqQIiU9T/PNLM79mUOg7Y8+kvuUTg2ATAosGNsEmYxMAyhgFoLrt3X4vJr5LUcTgH9DIUoWWkm92JE2buGbiSzH1Sxy7Rkkxufbw6HR42jeBeSufmm8PNQCo6S4n4bxMSipBRbl/Y7N+eb30JtuvdT10//jqRlmx/GvPinMPeHQnd/fjyXG7F4vnF5KFoePd2qqi1ez8Gnc9KaDAt1oDr9HDBgkA4Hmm81nQAaCq4bKG87IjmxggePlT36kYANDoexXdPS9EJ+6IYBM7QUgU0xb1YU3pGdjp2aO6bjS6pmbamu2dGUFr4HVH04AU33+X7U1vFmR880VlIVnYzKhLKXF+jZ9b5Z7sdRZTJ7E4H4vzi9vi0nYDreTQvaNHu+0PnIaWD9Dywat9FbkhLWqEl7BqhwWFZET7R91qDjxewt8qxteyIci4qpN03dr7Y7UGPgCspzuJ3XbEAF38nU250PA/0czNSc7TtPxw54yTMGIzN2LTgZlgdLblvB1TFk5YSKNgEpGQAsDrQ/3KRuHSY2Hrd/cv6fHDY9c3BFwAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"System call 흐름\",\n    \"title\": \"System call 흐름\",\n    \"src\": \"/static/ee64976e169dc92d8e349548304c99a6/7842b/Untitled1.png\",\n    \"srcSet\": [\"/static/ee64976e169dc92d8e349548304c99a6/f8f3a/Untitled1.png 200w\", \"/static/ee64976e169dc92d8e349548304c99a6/6a8a8/Untitled1.png 400w\", \"/static/ee64976e169dc92d8e349548304c99a6/7842b/Untitled1.png 800w\", \"/static/ee64976e169dc92d8e349548304c99a6/5ece7/Untitled1.png 1200w\", \"/static/ee64976e169dc92d8e349548304c99a6/0d4f8/Untitled1.png 1600w\", \"/static/ee64976e169dc92d8e349548304c99a6/a160d/Untitled1.png 3705w\"],\n    \"sizes\": \"(max-width: 800px) 100vw, 800px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"auto\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// zephyr/include/generated/syscall/gpio.h\\n\\n// compiler_barrier\\uB294 \\uCEF4\\uD30C\\uC77C\\uB7EC \\uCD5C\\uC801\\uD654\\uB85C \\uC778\\uD55C \\uC758\\uB3C4\\uCE58 \\uC54A\\uC740 \\uB3D9\\uC791\\uC744 \\uBC29\\uC9C0\\uD55C\\uB2E4.\\n#define compiler_barrier() do { \\\\\\n    __asm__ __volatile__ (\\\"\\\" ::: \\\"memory\\\"); \\\\\\n} while (false)\\n\\nstatic inline int z_impl_gpio_port_toggle_bits(const struct device *port,\\n                           gpio_port_pins_t pins)\\n{\\n    const struct gpio_driver_api *api =\\n        (const struct gpio_driver_api *)port->api;\\n\\n    return api->port_toggle_bits(port, pins);\\n}\\n\\n__pinned_func\\nstatic inline int gpio_port_toggle_bits(const struct device * port, gpio_port_pins_t pins)\\n{\\n#ifdef CONFIG_USERSPACE\\n    if (z_syscall_trap()) {\\n        union { uintptr_t x; const struct device * val; } parm0 = { .val = port };\\n        union { uintptr_t x; gpio_port_pins_t val; } parm1 = { .val = pins };\\n        return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_GPIO_PORT_TOGGLE_BITS);\\n    }\\n#endif\\n    compiler_barrier();\\n    return z_impl_gpio_port_toggle_bits(port, pins);\\n}\\n\")), mdx(\"p\", null, \"System call \\uD750\\uB984\"), mdx(\"p\", null, \"\\uC2E4\\uC81C \\uAD6C\\uD604\\uD568\\uC218\\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uAD6C\\uD604\\uB418\\uC5B4 \\uC788\\uB2E4. api\\u2192port_toggle_bits \\uD568\\uC218\\uB85C \\uACB0\\uAD6D \\uC2E4\\uD589\\uC774 \\uB418\\uB294\\uB370 \\uC774\\uB294 struct gpio_driver_api \\uAD6C\\uC870\\uCCB4\\uC5D0 \\uD568\\uC218\\uD3EC\\uC778\\uD130\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// zephyr/include/zephyr/drivers/gpio.h\\n\\n__subsystem struct gpio_driver_api {\\n    int (*pin_configure)(const struct device *port, gpio_pin_t pin,\\n                 gpio_flags_t flags);\\n#ifdef CONFIG_GPIO_GET_CONFIG\\n    int (*pin_get_config)(const struct device *port, gpio_pin_t pin,\\n                  gpio_flags_t *flags);\\n#endif\\n    int (*port_get_raw)(const struct device *port,\\n                gpio_port_value_t *value);\\n    int (*port_set_masked_raw)(const struct device *port,\\n                   gpio_port_pins_t mask,\\n                   gpio_port_value_t value);\\n    int (*port_set_bits_raw)(const struct device *port,\\n                 gpio_port_pins_t pins);\\n    int (*port_clear_bits_raw)(const struct device *port,\\n                   gpio_port_pins_t pins);\\n    int (*port_toggle_bits)(const struct device *port,\\n                gpio_port_pins_t pins);\\n    int (*pin_interrupt_configure)(const struct device *port,\\n                       gpio_pin_t pin,\\n                       enum gpio_int_mode, enum gpio_int_trig);\\n    int (*manage_callback)(const struct device *port,\\n                   struct gpio_callback *cb,\\n                   bool set);\\n    uint32_t (*get_pending_int)(const struct device *dev);\\n#ifdef CONFIG_GPIO_GET_DIRECTION\\n    int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,\\n                  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);\\n#endif /* CONFIG_GPIO_GET_DIRECTION */\\n};\\n\\nstatic inline int z_impl_gpio_port_toggle_bits(const struct device *port,\\n                           gpio_port_pins_t pins)\\n{\\n    const struct gpio_driver_api *api =\\n        (const struct gpio_driver_api *)port->api;\\n\\n    return api->port_toggle_bits(port, pins);\\n}\\n\")), mdx(\"p\", null, \"\\uC774 \\uD568\\uC218\\uD3EC\\uC778\\uD130\\uAC00 \\uC2E4\\uC81C \\uC2E4\\uD589\\uD568\\uC218\\uC778\\uB370 \\uAD6C\\uD604\\uB418\\uC5B4 \\uC788\\uB294\\uACF3\\uC740 Figure1\\uC5D0 \\uB530\\uB974\\uBA74 \\uC81C\\uC870\\uC0AC\\uB9C8\\uB2E4 \\uB2E4\\uB97C\\uAC83\\uC774\\uB2E4. nordic\\uCE69\\uC744 \\uAE30\\uC900\\uC73C\\uB85C \\uBCF4\\uBA74 \\uB2E4\\uC74C\\uACFC \\uAC19\\uB2E4. gpio_driver_api\\uB4E4\\uC740 gpio_nrfx_drv_api_funcs\\uB77C\\uB294 \\uC774\\uB984\\uC73C\\uB85C \\uB4F1\\uB85D\\uB418\\uC5B4 \\uC788\\uB2E4. gpio_nrfx_port_toggle_bits \\uD1A0\\uAE00 \\uB3D9\\uC791\\uC758 \\uAD6C\\uD604\\uD568\\uC218\\uB294 port_toggle_bits\\uC5D0 \\uD568\\uC218\\uD3EC\\uC778\\uD130\\uB85C \\uC804\\uB2EC\\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// zephyr/drviers/gpio/gpio_nrfx.c\\n\\nstatic int gpio_nrfx_port_toggle_bits(const struct device *port,\\n                      gpio_port_pins_t mask)\\n{\\n    NRF_GPIO_Type *reg = get_port_cfg(port)->port;\\n    const uint32_t value = nrf_gpio_port_out_read(reg) ^ mask;\\n    const uint32_t set_mask = value & mask;\\n    const uint32_t clear_mask = (~value) & mask;\\n\\n    nrf_gpio_port_out_set(reg, set_mask);\\n    nrf_gpio_port_out_clear(reg, clear_mask);\\n\\n    return 0;\\n}\\n\\nstatic const struct gpio_driver_api gpio_nrfx_drv_api_funcs = {\\n    .pin_configure = gpio_nrfx_pin_configure,\\n    .port_get_raw = gpio_nrfx_port_get_raw,\\n    .port_set_masked_raw = gpio_nrfx_port_set_masked_raw,\\n    .port_set_bits_raw = gpio_nrfx_port_set_bits_raw,\\n    .port_clear_bits_raw = gpio_nrfx_port_clear_bits_raw,\\n    .port_toggle_bits = gpio_nrfx_port_toggle_bits,\\n    .pin_interrupt_configure = gpio_nrfx_pin_interrupt_configure,\\n    .manage_callback = gpio_nrfx_manage_callback,\\n#ifdef CONFIG_GPIO_GET_DIRECTION\\n    .port_get_direction = gpio_nrfx_port_get_direction,\\n#endif\\n};\\n\")), mdx(\"p\", null, \"\\uCF54\\uB4DC\\uB97C \\uD55C\\uC904\\uC529 \\uC0B4\\uD3B4\\uBCF4\\uC790 \\uBA3C\\uC800 NRF_GPIO_Type\\uC740 mdk library\\uC5D0 \\uC788\\uB294 \\uCF54\\uB4DC\\uB85C nordic gpio\\uC5D0 \\uBC94\\uC6A9\\uC801\\uC73C\\uB85C \\uC0AC\\uC6A9\\uB41C\\uB2E4.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"nRF MDK\\uB294 nRF51, nRF52, nRF53 \\uBC0F nRF91 \\uC2DC\\uB9AC\\uC988 \\uC7A5\\uCE58 \\uAC1C\\uBC1C\\uC744 \\uB354 \\uBE60\\uB974\\uAC8C \\uC2DC\\uC791\\uD560 \\uC218 \\uC788\\uB3C4\\uB85D \\uB808\\uC9C0\\uC2A4\\uD130 \\uD5E4\\uB354 \\uD30C\\uC77C \\uBC0F \\uC2DC\\uC791 \\uCF54\\uB4DC \\uD615\\uD0DC\\uB85C \\uC7A5\\uCE58 \\uC9C0\\uC6D0\\uC744 \\uC81C\\uACF5\\uD569\\uB2C8\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"NRF_GPIO_Type *reg = get_port_cfg(port)->port;\\n\\n// module/hal/nordic/nrfx/mdk\\n\\n/**\\n  * @brief GPIO Port 1 (P0)\\n  */\\n\\ntypedef struct {                                /*!< (@ 0x50000000) P0 Structure                                               */\\n  __IM  uint32_t  RESERVED[321];\\n  __IOM uint32_t  OUT;                          /*!< (@ 0x00000504) Write GPIO port                                            */\\n  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000508) Set individual bits in GPIO port                           */\\n  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */\\n  __IM  uint32_t  IN;                           /*!< (@ 0x00000510) Read GPIO port                                             */\\n  __IOM uint32_t  DIR;                          /*!< (@ 0x00000514) Direction of GPIO pins                                     */\\n  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000518) DIR set register                                           */\\n  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000051C) DIR clear register                                         */\\n  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000520) Latch register indicating what GPIO pins that\\n                                                                    have met the criteria set in the PIN_CNF[n].SENSE\\n                                                                    registers                                                  */\\n  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000524) Select between default DETECT signal behaviour\\n                                                                    and LDETECT mode                                           */\\n  __IM  uint32_t  RESERVED1[118];\\n  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection: Configuration of GPIO\\n                                                                    pins                                                       */\\n} NRF_GPIO_Type;                                /*!< Size = 1920 (0x780)                                                       */\\n\\n// drviers/gpio/gpio_nrfx.c\\n\\nstatic inline const struct gpio_nrfx_cfg *get_port_cfg(const struct device *port)\\n{\\n    return port->config; // gpio_nrfx_pin_configure\\n}\\n\")), mdx(\"p\", null, \"nrf_gpio_port_out_read\\uB294 \\uD574\\uB2F9 \\uD3EC\\uD2B8\\uC758 GPIO \\uD540\\uC758 \\uCD9C\\uB825 \\uC2E0\\uD638\\uB97C \\uC77D\\uB294 \\uAE30\\uB2A5\"), mdx(\"p\", null, \"\\uC77D\\uC740 \\uC2E0\\uD638\\uB294 value\\uC5D0 xor\\uB85C toggle\\uB418\\uC5B4 \\uC800\\uC7A5\\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"const uint32_t value = nrf_gpio_port_out_read(reg) ^ mask;\\n\\n/**\\n * @brief Function for reading the output signals of the GPIO pins on the given port.\\n *\\n * @param p_reg Pointer to the peripheral registers structure.\\n *\\n * @return Port output values.\\n */\\nNRF_STATIC_INLINE uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg)\\n{\\n    return p_reg->OUT;\\n}\\n\")), mdx(\"p\", null, \"nordic\\uC758 gpio\\uAE30\\uB2A5\\uC740 \\uC870\\uAE08 \\uB3C5\\uD2B9\\uD588\\uB294\\uB370 clear\\uC640 set\\uB3D9\\uC791\\uC774 \\uB530\\uB85C\\uC788\\uB2E4. \\uB530\\uB77C\\uC11C toggle\\uC744 \\uC704\\uD574\\uC11C\\uB294 \\uB458\\uB2E4 \\uD574\\uC57C\\uD55C\\uB2E4.\"), mdx(\"p\", null, \"\\uB530\\uB77C\\uC11C \\uD1A0\\uAE00\\uB41C value\\uB97C set, clear\\uD568\\uC218\\uC5D0 \\uBAA8\\uB450 \\uC804\\uB2EC\\uD55C\\uB2E4.\"), mdx(\"p\", null, \"OUTSET Pin, Low 0 Read: pin driver is low, High 1 Read: pin driver is high\\nSet 1 Write: writing a \\u20181\\u2019 sets the pin high; writing a \\u20180\\u2019 has no effect\"), mdx(\"p\", null, \"OUTCLR Pin, Low 0 Read: pin driver is low, High 1 Read: pin driver is high\\nClear 1 Write: writing a \\u20181\\u2019 sets the pin low; writing a \\u20180\\u2019 has no effect\"), mdx(\"blockquote\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"const uint32_t set_mask = value & mask;\\nconst uint32_t clear_mask = (~value) & mask;\\n\\nnrf_gpio_port_out_set(reg, set_mask);\\nnrf_gpio_port_out_clear(reg, clear_mask);\\n\\n// modules/hal/nordic/nrfx/hal/nrf_gpio.h\\n\\n/**\\n * @brief Function for setting high level on selected the GPIO pins on the given port.\\n *\\n * @param p_reg    Pointer to the structure of registers of the peripheral.\\n * @param set_mask Mask with pins to be set as logical high level.\\n */\\nNRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask);\\n\\n/**\\n * @brief Function for setting low level on selected the GPIO pins on the given port.\\n *\\n * @param p_reg    Pointer to the structure of registers of the peripheral.\\n * @param clr_mask Mask with pins to be set as logical low level.\\n */\\nNRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask);\\n\\nNRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)\\n{\\n    p_reg->OUTSET = set_mask;\\n}\\n\\nNRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)\\n{\\n    p_reg->OUTCLR = clr_mask;\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"gpio-device-driver-정리\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#gpio-device-driver-%EC%A0%95%EB%A6%AC\",\n    \"aria-label\": \"gpio device driver 정리 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"GPIO Device Driver \\uC815\\uB9AC\"), mdx(\"p\", null, \"Figure1\\uC758 Generic\\uD55C API\\uB97C \\uC704\\uD574 \\uCF54\\uB4DC \\uBD84\\uAE30\\uAC00 \\uC0C1\\uB2F9\\uD788 \\uB9CE\\uB2E4. FlowChart\\uB85C \\uCD1D \\uC815\\uB9AC\\uD558\\uBA74 \\uB2E4\\uC74C\\uACFC \\uAC19\\uB2E4.\"), mdx(\"h3\", {\n    \"id\": \"generic-type-apis\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#generic-type-apis\",\n    \"aria-label\": \"generic type apis permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Generic Type APIs\"), mdx(\"p\", null, \"zephyr/include/drivers/gpio.h \\uD30C\\uC77C\\uC5D0 \\uBAA8\\uB450 Declare \\uB418\\uC5B4 \\uC788\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/**\\n * @brief Toggle pin level from a @p gpio_dt_spec.\\n *\\n * This is equivalent to:\\n *\\n *     gpio_pin_toggle(spec->port, spec->pin);\\n *\\n * @param spec GPIO specification from devicetree\\n * @return a value from gpio_pin_toggle()\\n */\\nstatic inline int gpio_pin_toggle_dt(const struct gpio_dt_spec *spec)\\n{\\n    return gpio_pin_toggle(spec->port, spec->pin);\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"device-driver-instances\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#device-driver-instances\",\n    \"aria-label\": \"device driver instances permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver Instances\"), mdx(\"p\", null, \"\\uB300\\uBD80\\uBD84\\uC758 \\uB4DC\\uB77C\\uC774\\uBC84\\uB294 \\uC7A5\\uCE58 \\uB3C5\\uB9BD\\uC801\\uC778 \\uD558\\uC704 \\uC2DC\\uC2A4\\uD15C API\\uAC00 \\uD544\\uC694\\uD558\\uB2E4.\\xA0\\uC77C\\uBC18\\uC801\\uC778 \\uC0AC\\uC6A9\\uC6A9\\uB3C4\\uB294 \\uD1B5\\uC77C\\uB418\\uC5B4 \\uC788\\uAE30 \\uB54C\\uBB38\\uC5D0 \\uD568\\uC218\\uD3EC\\uC778\\uD130 \\uAD6C\\uC870\\uCCB4\\uC5D0 \\uB4F1\\uB85D\\uD558\\uB294 \\uBC29\\uC2DD\\uC73C\\uB85C \\uC0AC\\uC6A9\\uD55C\\uB2E4. \\uC774\\uB85C\\uC778\\uD574 \\uC571 \\uC0AC\\uC6A9\\uC790\\uB294 \\uC2E4\\uC81C \\uAD6C\\uD604\\uD568\\uC218\\uB294 \\uC2E0\\uACBD\\uC4F8 \\uD544\\uC694\\uAC00 \\uC5C6\\uB2E4.\"), mdx(\"p\", null, \"zephyr/include/drivers/gpio.h\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"__subsystem struct gpio_driver_api {\\n    int (*pin_configure)(const struct device *port, gpio_pin_t pin,\\n                 gpio_flags_t flags);\\n#ifdef CONFIG_GPIO_GET_CONFIG\\n    int (*pin_get_config)(const struct device *port, gpio_pin_t pin,\\n                  gpio_flags_t *flags);\\n#endif\\n    int (*port_get_raw)(const struct device *port,\\n                gpio_port_value_t *value);\\n    int (*port_set_masked_raw)(const struct device *port,\\n                   gpio_port_pins_t mask,\\n                   gpio_port_value_t value);\\n    int (*port_set_bits_raw)(const struct device *port,\\n                 gpio_port_pins_t pins);\\n    int (*port_clear_bits_raw)(const struct device *port,\\n                   gpio_port_pins_t pins);\\n    int (*port_toggle_bits)(const struct device *port,\\n                gpio_port_pins_t pins);\\n    int (*pin_interrupt_configure)(const struct device *port,\\n                       gpio_pin_t pin,\\n                       enum gpio_int_mode, enum gpio_int_trig);\\n    int (*manage_callback)(const struct device *port,\\n                   struct gpio_callback *cb,\\n                   bool set);\\n    uint32_t (*get_pending_int)(const struct device *dev);\\n#ifdef CONFIG_GPIO_GET_DIRECTION\\n    int (*port_get_direction)(const struct device *port, gpio_port_pins_t map,\\n                  gpio_port_pins_t *inputs, gpio_port_pins_t *outputs);\\n#endif /* CONFIG_GPIO_GET_DIRECTION */\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"device-driver-implementations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#device-driver-implementations\",\n    \"aria-label\": \"device driver implementations permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver Implementations\"), mdx(\"p\", null, \"\\uC81C\\uC870\\uC0AC\\uBCC4 \\uC2E4\\uC81C \\uAD6C\\uD604 \\uB4DC\\uB77C\\uC774\\uBC84\"), mdx(\"p\", null, \"zephyr/drivers/gpio/gpio_nrfx.c\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"\\nstatic int gpio_nrfx_port_toggle_bits(const struct device *port,\\n                      gpio_port_pins_t mask)\\n{\\n    NRF_GPIO_Type *reg = get_port_cfg(port)->port;\\n    const uint32_t value = nrf_gpio_port_out_read(reg) ^ mask;\\n    const uint32_t set_mask = value & mask;\\n    const uint32_t clear_mask = (~value) & mask;\\n\\n    nrf_gpio_port_out_set(reg, set_mask);\\n    nrf_gpio_port_out_clear(reg, clear_mask);\\n\\n    return 0;\\n}\\n\\nstatic const struct gpio_driver_api gpio_nrfx_drv_api_funcs = {\\n    .pin_configure = gpio_nrfx_pin_configure,\\n    .port_get_raw = gpio_nrfx_port_get_raw,\\n    .port_set_masked_raw = gpio_nrfx_port_set_masked_raw,\\n    .port_set_bits_raw = gpio_nrfx_port_set_bits_raw,\\n    .port_clear_bits_raw = gpio_nrfx_port_clear_bits_raw,\\n    .port_toggle_bits = gpio_nrfx_port_toggle_bits,\\n    .pin_interrupt_configure = gpio_nrfx_pin_interrupt_configure,\\n    .manage_callback = gpio_nrfx_manage_callback,\\n#ifdef CONFIG_GPIO_GET_DIRECTION\\n    .port_get_direction = gpio_nrfx_port_get_direction,\\n#endif\\n};\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Device Driver analysis (1), Execution 제조사 별로 Device Driver를 작성 하여 Zephyr API구조에 맞춘다. 따라서 User는 Device Driver가 존재한다면 구현에 신경쓰지 않고 표준타입의 API…","tableOfContents":{"items":[{"url":"#device-driver-analysis-1-execution","title":"Device Driver analysis (1), Execution","items":[{"url":"#디바이스-드라이버-분석","title":"디바이스 드라이버 분석"},{"url":"#gpio-device-driver-정리","title":"GPIO Device Driver 정리","items":[{"url":"#generic-type-apis","title":"Generic Type APIs"},{"url":"#device-driver-instances","title":"Device Driver Instances"},{"url":"#device-driver-implementations","title":"Device Driver Implementations"}]}]}]},"fields":{"slug":"/nordic_connect_sdk/device_driver/Execution/"},"frontmatter":{"title":"Device Driver analysis (1), Execution","subTitle":"Zephyr RTOS Device Driver 분석","date":"Tuesday, September 26th 2023, 2:56  PM","cover":null}}},"pageContext":{"id":"0a687588-494f-515a-ac91-4a43c2dbdf43"}},
    "staticQueryHashes": ["1265008906","2270979341","3868834917"]}