{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/zephyr_rtos/device_driver/Declare_Define/",
    "result": {"data":{"mdx":{"id":"6c3573c2-ee00-5cb2-a45a-44f967f7a114","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Device Driver analysis (2), Declare & Define\",\n  \"subTitle\": \"Zephyr RTOS Device Driver 분석\",\n  \"category\": \"programmers\",\n  \"date\": \"2023-09-26T15:26:00.000Z\",\n  \"cover\": null\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"device-driver-analysis-2-declare--define\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#device-driver-analysis-2-declare--define\",\n    \"aria-label\": \"device driver analysis 2 declare  define permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver analysis (2), Declare & Define\"), mdx(\"p\", null, \"\\uC774\\uC5B4\\uC11C nrf gpio \\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84\\uC758 gpio_nrfx_port_toggle_bits() \\uD568\\uC218\\uAC00 \\uC5B4\\uB5BB\\uAC8C \\uB4F1\\uB85D \\uB418\\uB294\\uC9C0 \\uC0B4\\uD3B4\\uBCF8\\uB2E4.\"), mdx(\"h2\", {\n    \"id\": \"device-driver-declare\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#device-driver-declare\",\n    \"aria-label\": \"device driver declare permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Device Driver Declare\"), mdx(\"p\", null, \"\\uBA3C\\uC800 \\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84\\uC5D0\\uC11C \\uAD6C\\uD604\\uB41C \\uD568\\uC218\\uB294 api \\uAD6C\\uC870\\uCCB4\\uC5D0 \\uB4F1\\uB85D\\uC774 \\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// implement device drvier api fn\\nstatic int gpio_nrfx_port_toggle_bits(const struct device *port,\\n                      gpio_port_pins_t mask)\\n{\\n    NRF_GPIO_Type *reg = get_port_cfg(port)->port;\\n    const uint32_t value = nrf_gpio_port_out_read(reg) ^ mask;\\n    const uint32_t set_mask = value & mask;\\n    const uint32_t clear_mask = (~value) & mask;\\n\\n    nrf_gpio_port_out_set(reg, set_mask);\\n    nrf_gpio_port_out_clear(reg, clear_mask);\\n\\n    return 0;\\n}\\n\\n// instance device driver api struct\\nstatic const struct gpio_driver_api gpio_nrfx_drv_api_funcs = {\\n    .pin_configure = gpio_nrfx_pin_configure,\\n    .port_get_raw = gpio_nrfx_port_get_raw,\\n    .port_set_masked_raw = gpio_nrfx_port_set_masked_raw,\\n    .port_set_bits_raw = gpio_nrfx_port_set_bits_raw,\\n    .port_clear_bits_raw = gpio_nrfx_port_clear_bits_raw,\\n    .port_toggle_bits = gpio_nrfx_port_toggle_bits,\\n    .pin_interrupt_configure = gpio_nrfx_pin_interrupt_configure,\\n    .manage_callback = gpio_nrfx_manage_callback,\\n#ifdef CONFIG_GPIO_GET_DIRECTION\\n    .port_get_direction = gpio_nrfx_port_get_direction,\\n#endif\\n};\\n\")), mdx(\"p\", null, \"\\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84\\uC758 \\uC2E4\\uC81C \\uCF54\\uB4DC \\uC120\\uC5B8\\uC744 \\uC704\\uD574\\uC11C\\uB294 \\uC870\\uAC74\\uC774 \\uC788\\uB2E4\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"device-tree\\uC758 \\uD574\\uB2F9 \\uB178\\uB4DC status=\\u201Dokay\\u201D\\uC77C\\uAC83(status \\uC120\\uC5B8\\uC774 \\uC5C6\\uC744\\uACBD\\uC6B0 okay\\uB85C \\uCDE8\\uAE09)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Kconfig\\uC758 CONFIG_GPIO=y \\uC77C\\uAC83\")), mdx(\"p\", null, \"\\uB610\\uD55C GPIO\\uB294 \\uC5EC\\uB7EC\\uAC1C\\uC758 \\uD3EC\\uD2B8\\uAC00 \\uC874\\uC7AC\\uD560 \\uC218 \\uC788\\uC73C\\uBBC0\\uB85C implement fn code\\uAC00 \\uC5EC\\uB7EC\\uBC88 \\uC911\\uBCF5 \\uC0AC\\uC6A9\\uB420 \\uC218 \\uC788\\uB2E4. (\\uB2E8\\uC77C \\uB4DC\\uB77C\\uC774\\uBC84, \\uB2E4\\uC911 \\uC778\\uC2A4\\uD134\\uC2A4)\"), mdx(\"p\", null, \"\\uC704\\uC640\\uAC19\\uC740 \\uC870\\uAC74\\uC73C\\uB85C \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 Declare\\uAC00 \\uB418\\uC5B4\\uC788\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/* Device instantiation is done with node labels because 'port_num' is\\n * the peripheral number by SoC numbering. We therefore cannot use\\n * DT_INST APIs here without wider changes.\\n */\\n\\n/* \\uC7A5\\uCE58 \\uC778\\uC2A4\\uD134\\uC2A4\\uD654\\uB294 \\uB178\\uB4DC \\uB77C\\uBCA8\\uC744 \\uC0AC\\uC6A9\\uD558\\uC5EC \\uC218\\uD589\\uB418\\uBA70 'port_num'\\uC740 SoC \\uBC88\\uD638\\uC5D0 \\uB530\\uB978 \\uC8FC\\uBCC0 \\uC7A5\\uCE58 \\uBC88\\uD638\\uC785\\uB2C8\\uB2E4.\\n * \\uB530\\uB77C\\uC11C \\uC5EC\\uAE30\\uC11C\\uB294 \\uB354 \\uD070 \\uBCC0\\uACBD \\uC5C6\\uC774\\uB294 DT_INST API\\uB97C \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC5C6\\uC2B5\\uB2C8\\uB2E4\\n */\\n\\n#define GPIO_NRF_DEVICE(id)                     \\\\\\n    static const struct gpio_nrfx_cfg gpio_nrfx_p##id##_cfg = { \\\\\\n        .common = {                     \\\\\\n            .port_pin_mask =                \\\\\\n            GPIO_PORT_PIN_MASK_FROM_DT_INST(id),        \\\\\\n        },                          \\\\\\n        .port = (NRF_GPIO_Type *)DT_INST_REG_ADDR(id),      \\\\\\n        .port_num = DT_INST_PROP(id, port),         \\\\\\n        .edge_sense = DT_INST_PROP_OR(id, sense_edge_mask, 0)   \\\\\\n    };                              \\\\\\n                                    \\\\\\n    static struct gpio_nrfx_data gpio_nrfx_p##id##_data;        \\\\\\n                                    \\\\\\n    DEVICE_DT_INST_DEFINE(id, gpio_nrfx_init,           \\\\\\n             NULL,                      \\\\\\n             &gpio_nrfx_p##id##_data,           \\\\\\n             &gpio_nrfx_p##id##_cfg,            \\\\\\n             PRE_KERNEL_1,                  \\\\\\n             CONFIG_GPIO_INIT_PRIORITY,         \\\\\\n             &gpio_nrfx_drv_api_funcs);\\n\\nDT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_DEVICE)\\n\")), mdx(\"p\", null, \"DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_DEVICE)\\uB97C \\uBA3C\\uC800 \\uC0B4\\uD3B4\\uBCF4\\uBA74 \\uB9E4\\uD06C\\uB85C\\uD568\\uC218\\uB85C \\uC544\\uB798\\uC640 \\uAC19\\uC774 \\uC804\\uCC98\\uB9AC \\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/**\\n * @brief Call @p fn on all nodes with compatible `DT_DRV_COMPAT`\\n *        and status `okay`\\n *\\n * This macro calls `fn(inst)` on each `inst` number that refers to a\\n * node with status `okay`. Whitespace is added between invocations.\\n *\\n * Example devicetree fragment:\\n *\\n * @code{.dts}\\n *     a {\\n *             compatible = \\\"vnd,device\\\";\\n *             status = \\\"okay\\\";\\n *             foobar = \\\"DEV_A\\\";\\n *     };\\n *\\n *     b {\\n *             compatible = \\\"vnd,device\\\";\\n *             status = \\\"okay\\\";\\n *             foobar = \\\"DEV_B\\\";\\n *     };\\n *\\n *     c {\\n *             compatible = \\\"vnd,device\\\";\\n *             status = \\\"disabled\\\";\\n *             foobar = \\\"DEV_C\\\";\\n *     };\\n * @endcode\\n *\\n * Example usage:\\n *\\n * @code{.c}\\n *     #define DT_DRV_COMPAT vnd_device\\n *     #define MY_FN(inst) DT_INST_PROP(inst, foobar),\\n *\\n *     DT_INST_FOREACH_STATUS_OKAY(MY_FN)\\n * @endcode\\n *\\n * This expands to:\\n *\\n * @code{.c}\\n *     MY_FN(0) MY_FN(1)\\n * @endcode\\n *\\n * and from there, to either this:\\n *\\n *     \\\"DEV_A\\\", \\\"DEV_B\\\",\\n *\\n * or this:\\n *\\n *     \\\"DEV_B\\\", \\\"DEV_A\\\",\\n *\\n * No guarantees are made about the order that a and b appear in the\\n * expansion.\\n *\\n * Note that @p fn is responsible for adding commas, semicolons, or\\n * other separators or terminators.\\n *\\n * Device drivers should use this macro whenever possible to\\n * instantiate a struct device for each enabled node in the devicetree\\n * of the driver's compatible `DT_DRV_COMPAT`.\\n *\\n * @param fn Macro to call for each enabled node. Must accept an\\n *           instance number as its only parameter.\\n */\\n#define DT_DRV_COMPAT nordic_nrf_gpio\\n#define DT_INST_FOREACH_STATUS_OKAY(fn) \\\\\\n    COND_CODE_1(DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT),   \\\\\\n            (UTIL_CAT(DT_FOREACH_OKAY_INST_,        \\\\\\n                  DT_DRV_COMPAT)(fn)),      \\\\\\n            ())\\n\")), mdx(\"p\", null, \"gpio\\uC758 status=\\u201Dokay\\u201D\\uC778 \\uACBD\\uC6B0 \\uC804\\uCC98\\uB9AC\\uC758 \\uACB0\\uACFC\\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC740 \\uC21C\\uC11C\\uB85C \\uB420\\uAC83\\uC774\\uB2E4.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/0a216fd37b8ebee233688efa53dddeff/build-config-phase.svg\",\n    \"alt\": \"Configuration Phase\"\n  })), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"build/zephyr/zephyr.dts.pre\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uC804\\uCC98\\uB9AC\\uB41C DTS \\uC18C\\uC2A4\\uC785\\uB2C8\\uB2E4. \\uC774\\uB294 \\uC911\\uAC04 \\uCD9C\\uB825 \\uD30C\\uC77C\\uB85C, gen_defines.py\\uC758 \\uC785\\uB825\\uC73C\\uB85C \\uC0AC\\uC6A9\\uB418\\uBA70 zephyr.dts \\uBC0F devicetree_generated.h\\uB97C \\uC0DD\\uC131\\uD558\\uB294 \\uB370 \\uC0AC\\uC6A9\\uB429\\uB2C8\\uB2E4.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"build/zephyr/include/generated/devicetree_generated.h\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uC0DD\\uC131\\uB41C \\uB9E4\\uD06C\\uB85C \\uBC0F \\uB514\\uBC14\\uC774\\uC2A4 \\uD2B8\\uB9AC\\uB97C \\uC124\\uBA85\\uD558\\uB294 \\uCD94\\uAC00 \\uCF54\\uBA58\\uD2B8\\uAC00 \\uD3EC\\uD568\\uB418\\uC5B4 \\uC788\\uC2B5\\uB2C8\\uB2E4. devicetree.h\\uC5D0 \\uD3EC\\uD568\\uB429\\uB2C8\\uB2E4.\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"build/zephyr/zephyr.dts\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uCD5C\\uC885 \\uBCD1\\uD569\\uB41C \\uB514\\uBC14\\uC774\\uC2A4 \\uD2B8\\uB9AC\\uC785\\uB2C8\\uB2E4. \\uC774 \\uD30C\\uC77C\\uC740 gen_defines.py\\uC5D0 \\uC758\\uD574 \\uCD9C\\uB825\\uB429\\uB2C8\\uB2E4. \\uC774 \\uD30C\\uC77C\\uC744 \\uC0AC\\uC6A9\\uD558\\uC5EC \\uBB38\\uC81C\\uB97C \\uB514\\uBC84\\uAE45\\uD558\\uB294 \\uB370 \\uC720\\uC6A9\\uD569\\uB2C8\\uB2E4. \\uB514\\uBC14\\uC774\\uC2A4 \\uD2B8\\uB9AC \\uCEF4\\uD30C\\uC77C\\uB7EC dtc\\uAC00 \\uC124\\uCE58\\uB41C \\uACBD\\uC6B0 \\uC774 \\uD30C\\uC77C\\uC5D0\\uC11C\\uB3C4 \\uC2E4\\uD589\\uB418\\uC5B4 \\uCD94\\uAC00 \\uACBD\\uACE0 \\uB610\\uB294 \\uC624\\uB958\\uB97C \\uC7A1\\uC2B5\\uB2C8\\uB2E4.\\u201D\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// 1\\n// DT_HAS_COMPAT_STATUS_OKAY(nordic_nrf_gpio) == 1\\n#define DT_INST_FOREACH_STATUS_OKAY(fn) \\\\\\n    COND_CODE_1(1, (DT_FOREACH_OKAY_INST_nordic_nrf_gpio(fn)), ())\\n\\n// 2\\n// (UTIL_CAT(DT_FOREACH_OKAY_INST_, nordic_nrf_gpio)(GPIO_NRF_DEVICE)) \\uD568\\uC218\\uAC00 \\uB4F1\\uB85D\\uB41C\\uB2E4.\\n__DEBRACKET(DT_FOREACH_OKAY_INST_nordic_nrf_gpio(GPIO_NRF_DEVICE))\\n\\n// 3\\nDT_FOREACH_OKAY_INST_nordic_nrf_gpio(GPIO_NRF_DEVICE)\\n\\n// DT_FOREACH_OKAY_INST_nordic_nrf_gpio\\uB294 zephyr/include/generated/devicetree_generated.h\\uC5D0 \\uC120\\uC5B8\\uB418\\uC5B4 \\uC788\\uB2E4.\\n// nrf52832\\uC758 gpio\\uB294 0port\\uB9CC \\uC874\\uC7AC\\uD55C\\uB2E4.\\n#define DT_FOREACH_OKAY_INST_nordic_nrf_gpio(fn) fn(0)\\n\")), mdx(\"p\", null, \"\\uACB0\\uAD6D gpio\\uB294 0\\uD3EC\\uD2B8\\uB9CC \\uC874\\uC7AC\\uD558\\uBBC0\\uB85C GPIO_NRF_DEVICE(0)\\uAC00 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uD55C\\uBC88 \\uD638\\uCD9C\\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// fn(0)\\uC774\\uBBC0\\uB85C \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uB41C\\uB2E4\\nstatic const struct gpio_nrfx_cfg gpio_nrfx_p0_cfg = {  \\\\\\n    .common = {                     \\\\\\n        .port_pin_mask =                \\\\\\n        GPIO_PORT_PIN_MASK_FROM_DT_INST(0),     \\\\\\n    },                          \\\\\\n    .port = (NRF_GPIO_Type *)DT_INST_REG_ADDR(0),       \\\\\\n    .port_num = DT_INST_PROP(id, port),         \\\\\\n    .edge_sense = DT_INST_PROP_OR(id, sense_edge_mask, 0)   \\\\\\n};                              \\\\\\n                                \\\\\\nstatic struct gpio_nrfx_data gpio_nrfx_p0_data;     \\\\\\n                                \\\\\\n\\nDEVICE_DT_INST_DEFINE(id, gpio_nrfx_init,           \\\\\\n         NULL,                      \\\\\\n         &gpio_nrfx_p0_data,            \\\\\\n         &gpio_nrfx_p0_cfg,         \\\\\\n         PRE_KERNEL_1,                  \\\\\\n         CONFIG_GPIO_INIT_PRIORITY,         \\\\\\n         &gpio_nrfx_drv_api_funcs);\\n\")), mdx(\"p\", null, \"\\uD574\\uB2F9 \\uCF54\\uB4DC\\uC758 gpio_nrfx_cfg \\uAD6C\\uC870\\uCCB4\\uB294 precompile\\uC744 \\uB05D\\uB0B8\\uB2E4\\uBA74 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"// fn(0)\\uC774\\uBBC0\\uB85C \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uB41C\\uB2E4\\nstatic const struct gpio_nrfx_cfg gpio_nrfx_p0_cfg = {\\n    .common = {\\n        .port_pin_mask = ((gpio_port_pins_t)(((uint64_t)1 << (32)) - 1U)),\\n    },\\n    .port = (NRF_GPIO_Type *)0x50000000, // GPIO 0 Address\\n    .port_num = 0, // DT_N_S_soc_S_gpio_50000000_P_port == 0\\n    .edge_sense = 0\\n};\\n\\nstatic struct gpio_nrfx_data gpio_nrfx_p0_data;\\n\")), mdx(\"p\", null, \"Device instance \\uC0DD\\uC131\\uC740 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC774 \\uB41C\\uB2E4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"//1\\n/**\\n * @brief DEVICE_DT_DEFINE()\\uC640 \\uC720\\uC0AC\\uD558\\uC9C0\\uB9CC `DT_DRV_COMPAT` \\uD638\\uD658 \\uC778\\uC2A4\\uD134\\uC2A4\\uB97C \\uC0AC\\uC6A9\\uD558\\uB294 \\uB300\\uC2E0\\uC5D0 \\uC778\\uC2A4\\uD134\\uC2A4 \\uBC88\\uD638\\uB97C \\uC0AC\\uC6A9\\uD569\\uB2C8\\uB2E4.\\n *\\n * @param inst \\uC778\\uC2A4\\uD134\\uC2A4 \\uBC88\\uD638. DEVICE_DT_DEFINE()\\uC758 `node_id` \\uC778\\uC218\\uB294 `DT_DRV_INST(inst)`\\uB85C \\uC124\\uC815\\uB429\\uB2C8\\uB2E4.\\n * @param ... DEVICE_DT_DEFINE()\\uC5D0\\uC11C \\uC608\\uC0C1\\uB418\\uB294 \\uB2E4\\uB978 \\uB9E4\\uAC1C\\uBCC0\\uC218\\uB4E4.\\n */\\nDEVICE_DT_INST_DEFINE(id, gpio_nrfx_init,           \\\\\\n         NULL,                      \\\\\\n         &gpio_nrfx_p0_data,            \\\\\\n         &gpio_nrfx_p0_cfg,         \\\\\\n         PRE_KERNEL_1,                  \\\\\\n         CONFIG_GPIO_INIT_PRIORITY,         \\\\\\n         &gpio_nrfx_drv_api_funcs);\\n\\n//2\\n/**\\n * @brief \\uB514\\uBC14\\uC774\\uC2A4 \\uD2B8\\uB9AC \\uB178\\uB4DC \\uC2DD\\uBCC4\\uC790\\uC5D0\\uC11C \\uB514\\uBC14\\uC774\\uC2A4 \\uAC1D\\uCCB4\\uB97C \\uC0DD\\uC131\\uD558\\uACE0 \\uBD80\\uD305 \\uC2DC \\uCD08\\uAE30\\uD654\\uB97C \\uC704\\uD574 \\uC124\\uC815\\uD569\\uB2C8\\uB2E4.\\n *\\n * \\uC774 \\uB9E4\\uD06C\\uB85C\\uB294 \\uC2DC\\uC2A4\\uD15C \\uCD08\\uAE30\\uD654 \\uC911\\uC5D0 \\uCEE4\\uB110\\uC5D0 \\uC758\\uD574 \\uC790\\uB3D9\\uC73C\\uB85C \\uAD6C\\uC131\\uB418\\uB294 \\uB514\\uBC14\\uC774\\uC2A4\\uB97C \\uC815\\uC758\\uD569\\uB2C8\\uB2E4. \\uC804\\uC5ED \\uB514\\uBC14\\uC774\\uC2A4 \\uAC1D\\uCCB4\\uC758 C \\uC2DD\\uBCC4\\uC790\\uB85C\\uC11C\\uC758 \\uC774\\uB984\\uC740 \\uB178\\uB4DC\\uC758 \\uC885\\uC18D\\uC131 \\uC11C\\uC218\\uC5D0\\uC11C \\uC720\\uB3C4\\uB429\\uB2C8\\uB2E4. device::name\\uC740 DEVICE_DT_NAME(node_id)\\uB85C \\uC124\\uC815\\uB429\\uB2C8\\uB2E4.\\n\\n * \\uB514\\uBC14\\uC774\\uC2A4\\uB294 extern \\uAC00\\uC2DC\\uC131\\uC73C\\uB85C \\uC120\\uC5B8\\uB418\\uBBC0\\uB85C <zephyr/device.h>\\uB97C \\uD3EC\\uD568\\uD558\\uB294 \\uBAA8\\uB4E0 \\uC18C\\uC2A4 \\uD30C\\uC77C\\uC5D0\\uC11C DEVICE_DT_GET(node_id)\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC \\uC804\\uC5ED \\uB514\\uBC14\\uC774\\uC2A4 \\uAC1D\\uCCB4\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB97C \\uC5BB\\uC744 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4. \\uD3EC\\uC778\\uD130\\uB97C \\uC0AC\\uC6A9\\uD558\\uAE30 \\uC804\\uC5D0 device_is_ready()\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC \\uCC38\\uC870\\uB41C \\uAC1D\\uCCB4\\uB97C \\uD655\\uC778\\uD574\\uC57C \\uD569\\uB2C8\\uB2E4.\\n\\n * \\uB9E4\\uAC1C\\uBCC0\\uC218\\n * node_id: \\uB514\\uBC14\\uC774\\uC2A4 \\uD2B8\\uB9AC \\uB178\\uB4DC \\uC2DD\\uBCC4\\uC790.\\n * init_fn: \\uB514\\uBC14\\uC774\\uC2A4 \\uCD08\\uAE30\\uD654 \\uD568\\uC218\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB85C, \\uCEE4\\uB110\\uC5D0\\uC11C \\uC2DC\\uC2A4\\uD15C \\uCD08\\uAE30\\uD654 \\uC911\\uC5D0 \\uC2E4\\uD589\\uB429\\uB2C8\\uB2E4. NULL\\uC77C \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\\n * pm: \\uB514\\uBC14\\uC774\\uC2A4\\uC758 \\uC804\\uC6D0 \\uAD00\\uB9AC \\uB9AC\\uC18C\\uC2A4\\uC778 pm_device\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB85C, device::pm\\uC5D0 \\uC800\\uC7A5\\uB429\\uB2C8\\uB2E4. \\uB514\\uBC14\\uC774\\uC2A4\\uAC00 \\uC804\\uC6D0 \\uAD00\\uB9AC\\uB97C \\uC0AC\\uC6A9\\uD558\\uC9C0 \\uC54A\\uB294 \\uACBD\\uC6B0 NULL\\uC744 \\uC0AC\\uC6A9\\uD558\\uC138\\uC694.\\n * data: \\uB514\\uBC14\\uC774\\uC2A4\\uC758 \\uAC1C\\uC778 \\uBBA4\\uD130\\uBE14 \\uB370\\uC774\\uD130\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB85C, device::data\\uC5D0 \\uC800\\uC7A5\\uB429\\uB2C8\\uB2E4.\\n * config: \\uB514\\uBC14\\uC774\\uC2A4\\uC758 \\uAC1C\\uC778 \\uC0C1\\uC218 \\uB370\\uC774\\uD130\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB85C, device::config \\uD544\\uB4DC\\uC5D0 \\uC800\\uC7A5\\uB429\\uB2C8\\uB2E4.\\n * level: \\uB514\\uBC14\\uC774\\uC2A4\\uC758 \\uCD08\\uAE30\\uD654 \\uB808\\uBCA8 (PRE_KERNEL_1, PRE_KERNEL_2 \\uB610\\uB294 POST_KERNEL).\\n * prio: \\uCD08\\uAE30\\uD654 \\uB808\\uBCA8 \\uB0B4\\uC5D0\\uC11C \\uB514\\uBC14\\uC774\\uC2A4\\uC758 \\uC6B0\\uC120\\uC21C\\uC704. \\uC790\\uC138\\uD55C \\uB0B4\\uC6A9\\uC740 SYS_INIT()\\uC744 \\uCC38\\uC870\\uD558\\uC138\\uC694.\\n * api: \\uB514\\uBC14\\uC774\\uC2A4\\uC758 API \\uAD6C\\uC870\\uC5D0 \\uB300\\uD55C \\uD3EC\\uC778\\uD130\\uB85C, NULL\\uC77C \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\\n */\\nDEVICE_DT_DEFINE(DT_N_S_soc_S_gpio_50000000, init_fn, pm, data, config, level, prio, api, ...)\\n\\n//3 \\uCEE4\\uB110\\uC5D0 \\uC758\\uD574 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC740 \\uB514\\uBC14\\uC774\\uC2A4 \\uAD6C\\uC870\\uCCB4 \\uC778\\uC2A4\\uD134\\uC2A4\\uAC00 \\uC0DD\\uC131\\uC774 \\uB420 \\uAC83\\uC774\\uBA70 \\uC0AC\\uC6A9\\uC790\\uAC00 \\uC0AC\\uC6A9\\uAC00\\uB2A5\\uD558\\uAC8C \\uB41C\\uB2E4.\\n/**\\n * @brief Runtime device structure (in ROM) per driver instance\\n */\\nstruct device {\\n    /** Name of the device instance */\\n    const char *name;\\n    /** Address of device instance config information */\\n    const void *config;\\n    /** Address of the API structure exposed by the device instance */\\n    const void *api;\\n    /** Address of the common device state */\\n    struct device_state *state;\\n    /** Address of the device instance private data */\\n    void *data;\\n    /**\\n     * Optional pointer to handles associated with the device.\\n     *\\n     * This encodes a sequence of sets of device handles that have some\\n     * relationship to this node. The individual sets are extracted with\\n     * dedicated API, such as device_required_handles_get().\\n     */\\n    Z_DEVICE_HANDLES_CONST device_handle_t *handles;\\n\\n#if defined(CONFIG_PM_DEVICE) || defined(__DOXYGEN__)\\n    /**\\n     * Reference to the device PM resources (only available if\\n     * @kconfig{CONFIG_PM_DEVICE} is enabled).\\n     */\\n    struct pm_device *pm;\\n#endif\\n};\\n\")), mdx(\"h2\", {\n    \"id\": \"결론\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#%EA%B2%B0%EB%A1%A0\",\n    \"aria-label\": \"결론 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"\\uACB0\\uB860\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\uB514\\uBC14\\uC774\\uC2A4 \\uB4DC\\uB77C\\uC774\\uBC84 \\uAC1C\\uBC1C\\uC790\\uB294 gpio_driver_api()\\uC5D0 \\uB4F1\\uB85D\\uB420 \\uD568\\uC218\\uB4E4\\uC744 \\uC791\\uC131\\uD55C\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Board\\uC758 Gpio status=\\u201Dokay\\u201D\\uBA74\\uC11C CONFIG_GPIO=y\\uB77C\\uBA74 GPIO_NRF_DEVICE(0)\\uAC00 \\uC120\\uC5B8\\uB428\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"gpio_nrfx_cfg, gpio_nrfx_data \\uAD6C\\uC870\\uCCB4\\uAC00 \\uC0DD\\uC131\\uB428\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"DEVICE_DT_DEFINE()\\uB85C \\uC7A5\\uCE58 \\uD2B8\\uB9AC \\uB178\\uB4DC \\uC2DD\\uBCC4\\uC790\\uB85C \\uC7A5\\uCE58 \\uAC1C\\uCCB4\\uB97C \\uC0DD\\uC131\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Device Driver analysis (2), Declare & Define 이어서 nrf gpio 디바이스 드라이버의 gpio_nrfx_port_toggle_bits() 함수가 어떻게 등록 되는지 살펴본다. Device Driver Declare…","tableOfContents":{"items":[{"url":"#device-driver-analysis-2-declare--define","title":"Device Driver analysis (2), Declare & Define","items":[{"url":"#device-driver-declare","title":"Device Driver Declare"},{"url":"#결론","title":"결론"}]}]},"fields":{"slug":"/zephyr_rtos/device_driver/Declare_Define/"},"frontmatter":{"title":"Device Driver analysis (2), Declare & Define","subTitle":"Zephyr RTOS Device Driver 분석","date":"Tuesday, September 26th 2023, 3:26  PM","cover":null}}},"pageContext":{"id":"6c3573c2-ee00-5cb2-a45a-44f967f7a114"}},
    "staticQueryHashes": ["1265008906","2270979341","3868834917"]}