{"version":3,"file":"687-4d50912ba1ef38b8d2bd.js","mappings":"qRAiFS,M,oECwTT,IAIIA,EAAO,GAubPC,EArbU,SAAiBC,GAG7B,IAFA,IAESC,EAAK,EAAGC,EAFNC,OAAOC,KAAKJ,GAEQC,EAAKC,EAAMG,OAAQJ,IAAM,CACtD,IAAIK,EAAMJ,EAAMD,GAChBH,EAAKQ,GAAON,EAAIM,KAubhBC,EAAU,CACZC,OAAQ,EAAAC,EACRC,GAAI,EAAAC,EACJC,SAAU,EAAAD,EACVE,OAAQ,IACRC,KAAM,SAAcd,GACbA,EAAIe,YACPf,EAAIe,UAAY,IAGlBf,EAAIe,UAAUC,oBAAsBhB,EAAIgB,oBACxCjB,EAAqBC,EAAIe,WACzB,EAAAJ,EAAA,QACA,EAAAA,EAAA,OAAc","sources":["webpack://bradkim06/./node_modules/dagre-d3-es/src/dagre-js/render.js","webpack://bradkim06/./node_modules/mermaid/dist/flowDiagram-46a15f6f.js"],"sourcesContent":["import * as d3 from 'd3';\nimport * as _ from 'lodash-es';\nimport { layout } from '../dagre/index.js';\nimport { arrows, setArrows } from './arrows.js';\nimport { createClusters, setCreateClusters } from './create-clusters.js';\nimport { createEdgeLabels, setCreateEdgeLabels } from './create-edge-labels.js';\nimport { createEdgePaths, setCreateEdgePaths } from './create-edge-paths.js';\nimport { createNodes, setCreateNodes } from './create-nodes.js';\nimport { positionClusters } from './position-clusters.js';\nimport { positionEdgeLabels } from './position-edge-labels.js';\nimport { positionNodes } from './position-nodes.js';\nimport { shapes, setShapes } from './shapes.js';\nexport { render }; // This design is based on http://bost.ocks.org/mike/chart/.\n\nfunction render() {\n  var fn = function fn(svg, g) {\n    preProcessGraph(g);\n    var outputGroup = createOrSelectGroup(svg, 'output');\n    var clustersGroup = createOrSelectGroup(outputGroup, 'clusters');\n    var edgePathsGroup = createOrSelectGroup(outputGroup, 'edgePaths');\n    var edgeLabels = createEdgeLabels(createOrSelectGroup(outputGroup, 'edgeLabels'), g);\n    var nodes = createNodes(createOrSelectGroup(outputGroup, 'nodes'), g, shapes);\n    layout(g);\n    positionNodes(nodes, g);\n    positionEdgeLabels(edgeLabels, g);\n    createEdgePaths(edgePathsGroup, g, arrows);\n    var clusters = createClusters(clustersGroup, g);\n    positionClusters(clusters, g);\n    postProcessGraph(g);\n  };\n\n  fn.createNodes = function (value) {\n    if (!arguments.length) return createNodes;\n    setCreateNodes(value);\n    return fn;\n  };\n\n  fn.createClusters = function (value) {\n    if (!arguments.length) return createClusters;\n    setCreateClusters(value);\n    return fn;\n  };\n\n  fn.createEdgeLabels = function (value) {\n    if (!arguments.length) return createEdgeLabels;\n    setCreateEdgeLabels(value);\n    return fn;\n  };\n\n  fn.createEdgePaths = function (value) {\n    if (!arguments.length) return createEdgePaths;\n    setCreateEdgePaths(value);\n    return fn;\n  };\n\n  fn.shapes = function (value) {\n    if (!arguments.length) return shapes;\n    setShapes(value);\n    return fn;\n  };\n\n  fn.arrows = function (value) {\n    if (!arguments.length) return arrows;\n    setArrows(value);\n    return fn;\n  };\n\n  return fn;\n}\n\nvar NODE_DEFAULT_ATTRS = {\n  paddingLeft: 10,\n  paddingRight: 10,\n  paddingTop: 10,\n  paddingBottom: 10,\n  rx: 0,\n  ry: 0,\n  shape: 'rect'\n};\nvar EDGE_DEFAULT_ATTRS = {\n  arrowhead: 'normal',\n  curve: d3.curveLinear\n};\n\nfunction preProcessGraph(g) {\n  g.nodes().forEach(function (v) {\n    var node = g.node(v);\n\n    if (!_.has(node, 'label') && !g.children(v).length) {\n      node.label = v;\n    }\n\n    if (_.has(node, 'paddingX')) {\n      _.defaults(node, {\n        paddingLeft: node.paddingX,\n        paddingRight: node.paddingX\n      });\n    }\n\n    if (_.has(node, 'paddingY')) {\n      _.defaults(node, {\n        paddingTop: node.paddingY,\n        paddingBottom: node.paddingY\n      });\n    }\n\n    if (_.has(node, 'padding')) {\n      _.defaults(node, {\n        paddingLeft: node.padding,\n        paddingRight: node.padding,\n        paddingTop: node.padding,\n        paddingBottom: node.padding\n      });\n    }\n\n    _.defaults(node, NODE_DEFAULT_ATTRS);\n\n    _.each(['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'], function (k) {\n      node[k] = Number(node[k]);\n    }); // Save dimensions for restore during post-processing\n\n\n    if (_.has(node, 'width')) {\n      node._prevWidth = node.width;\n    }\n\n    if (_.has(node, 'height')) {\n      node._prevHeight = node.height;\n    }\n  });\n  g.edges().forEach(function (e) {\n    var edge = g.edge(e);\n\n    if (!_.has(edge, 'label')) {\n      edge.label = '';\n    }\n\n    _.defaults(edge, EDGE_DEFAULT_ATTRS);\n  });\n}\n\nfunction postProcessGraph(g) {\n  _.each(g.nodes(), function (v) {\n    var node = g.node(v); // Restore original dimensions\n\n    if (_.has(node, '_prevWidth')) {\n      node.width = node._prevWidth;\n    } else {\n      delete node.width;\n    }\n\n    if (_.has(node, '_prevHeight')) {\n      node.height = node._prevHeight;\n    } else {\n      delete node.height;\n    }\n\n    delete node._prevWidth;\n    delete node._prevHeight;\n  });\n}\n\nfunction createOrSelectGroup(root, name) {\n  var selection = root.select('g.' + name);\n\n  if (selection.empty()) {\n    selection = root.append('g').attr('class', name);\n  }\n\n  return selection;\n}","function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { p as parser, f as flowDb } from \"./flowDb-52e24d17.js\";\nimport * as graphlib from \"dagre-d3-es/src/graphlib/index.js\";\nimport { select, curveLinear, selectAll } from \"d3\";\nimport { k as evaluate, g as getConfig, e as common, l as log } from \"./commonDb-573409be.js\";\nimport { render } from \"dagre-d3-es\";\nimport { applyStyle } from \"dagre-d3-es/src/dagre-js/util.js\";\nimport { addHtmlLabel } from \"dagre-d3-es/src/dagre-js/label/add-html-label.js\";\nimport { n as getStylesFromArray, o as interpolateToCurve, s as setupGraphViewbox } from \"./utils-d622194a.js\";\nimport { intersectPolygon } from \"dagre-d3-es/src/dagre-js/intersect/intersect-polygon.js\";\nimport { intersectRect } from \"dagre-d3-es/src/dagre-js/intersect/intersect-rect.js\";\nimport { f as flowRendererV2, a as flowStyles } from \"./styles-26373982.js\";\nimport \"./mermaidAPI-3ae0f2f0.js\";\nimport \"stylis\";\nimport \"dompurify\";\nimport \"lodash-es/isEmpty.js\";\nimport \"dayjs\";\nimport \"khroma\";\nimport \"@braintree/sanitize-url\";\nimport \"lodash-es/memoize.js\";\nimport \"./index-5219d011.js\";\nimport \"dagre-d3-es/src/dagre/index.js\";\nimport \"dagre-d3-es/src/graphlib/json.js\";\nimport \"./edges-2e77835f.js\";\nimport \"./createText-1f5f8f92.js\";\nimport \"@khanacademy/simple-markdown\";\nimport \"./svgDraw-2526cba0.js\";\n\nfunction question(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var s = (w + h) * 0.9;\n  var points = [{\n    x: s / 2,\n    y: 0\n  }, {\n    x: s,\n    y: -s / 2\n  }, {\n    x: s / 2,\n    y: -s\n  }, {\n    x: 0,\n    y: -s / 2\n  }];\n  var shapeSvg = insertPolygonShape(parent, s, s, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction hexagon(parent, bbox, node) {\n  var f = 4;\n  var h = bbox.height;\n  var m = h / f;\n  var w = bbox.width + 2 * m;\n  var points = [{\n    x: m,\n    y: 0\n  }, {\n    x: w - m,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w - m,\n    y: -h\n  }, {\n    x: m,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction rect_left_inv_arrow(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: -h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: -h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h / 2\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction lean_right(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction lean_left(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: 2 * h / 6,\n    y: 0\n  }, {\n    x: w + h / 6,\n    y: 0\n  }, {\n    x: w - 2 * h / 6,\n    y: -h\n  }, {\n    x: -h / 6,\n    y: -h\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction trapezoid(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: -2 * h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: -h\n  }, {\n    x: h / 6,\n    y: -h\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction inv_trapezoid(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: h / 6,\n    y: 0\n  }, {\n    x: w - h / 6,\n    y: 0\n  }, {\n    x: w + 2 * h / 6,\n    y: -h\n  }, {\n    x: -2 * h / 6,\n    y: -h\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction rect_right_inv_arrow(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w + h / 2,\n    y: 0\n  }, {\n    x: w,\n    y: -h / 2\n  }, {\n    x: w + h / 2,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction stadium(parent, bbox, node) {\n  var h = bbox.height;\n  var w = bbox.width + h / 4;\n  var shapeSvg = parent.insert(\"rect\", \":first-child\").attr(\"rx\", h / 2).attr(\"ry\", h / 2).attr(\"x\", -w / 2).attr(\"y\", -h / 2).attr(\"width\", w).attr(\"height\", h);\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction subroutine(parent, bbox, node) {\n  var w = bbox.width;\n  var h = bbox.height;\n  var points = [{\n    x: 0,\n    y: 0\n  }, {\n    x: w,\n    y: 0\n  }, {\n    x: w,\n    y: -h\n  }, {\n    x: 0,\n    y: -h\n  }, {\n    x: 0,\n    y: 0\n  }, {\n    x: -8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: 0\n  }, {\n    x: w + 8,\n    y: -h\n  }, {\n    x: -8,\n    y: -h\n  }, {\n    x: -8,\n    y: 0\n  }];\n  var shapeSvg = insertPolygonShape(parent, w, h, points);\n\n  node.intersect = function (point) {\n    return intersectPolygon(node, points, point);\n  };\n\n  return shapeSvg;\n}\n\nfunction cylinder(parent, bbox, node) {\n  var w = bbox.width;\n  var rx = w / 2;\n  var ry = rx / (2.5 + w / 50);\n  var h = bbox.height + ry;\n  var shape = \"M 0,\" + ry + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 a \" + rx + \",\" + ry + \" 0,0,0 \" + -w + \" 0 l 0,\" + h + \" a \" + rx + \",\" + ry + \" 0,0,0 \" + w + \" 0 l 0,\" + -h;\n  var shapeSvg = parent.attr(\"label-offset-y\", ry).insert(\"path\", \":first-child\").attr(\"d\", shape).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + -(h / 2 + ry) + \")\");\n\n  node.intersect = function (point) {\n    var pos = intersectRect(node, point);\n    var x = pos.x - node.x;\n\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      var y = ry * ry * (1 - x * x / (rx * rx));\n\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n\n      y = ry - y;\n\n      if (point.y - node.y > 0) {\n        y = -y;\n      }\n\n      pos.y += y;\n    }\n\n    return pos;\n  };\n\n  return shapeSvg;\n}\n\nfunction addToRender(render2) {\n  render2.shapes().question = question;\n  render2.shapes().hexagon = hexagon;\n  render2.shapes().stadium = stadium;\n  render2.shapes().subroutine = subroutine;\n  render2.shapes().cylinder = cylinder;\n  render2.shapes().rect_left_inv_arrow = rect_left_inv_arrow;\n  render2.shapes().lean_right = lean_right;\n  render2.shapes().lean_left = lean_left;\n  render2.shapes().trapezoid = trapezoid;\n  render2.shapes().inv_trapezoid = inv_trapezoid;\n  render2.shapes().rect_right_inv_arrow = rect_right_inv_arrow;\n}\n\nfunction addToRenderV2(addShape) {\n  addShape({\n    question: question\n  });\n  addShape({\n    hexagon: hexagon\n  });\n  addShape({\n    stadium: stadium\n  });\n  addShape({\n    subroutine: subroutine\n  });\n  addShape({\n    cylinder: cylinder\n  });\n  addShape({\n    rect_left_inv_arrow: rect_left_inv_arrow\n  });\n  addShape({\n    lean_right: lean_right\n  });\n  addShape({\n    lean_left: lean_left\n  });\n  addShape({\n    trapezoid: trapezoid\n  });\n  addShape({\n    inv_trapezoid: inv_trapezoid\n  });\n  addShape({\n    rect_right_inv_arrow: rect_right_inv_arrow\n  });\n}\n\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\"points\", points.map(function (d) {\n    return d.x + \",\" + d.y;\n  }).join(\" \")).attr(\"transform\", \"translate(\" + -w / 2 + \",\" + h / 2 + \")\");\n}\n\nvar flowChartShapes = {\n  addToRender: addToRender,\n  addToRenderV2: addToRenderV2\n};\nvar conf = {};\n\nvar setConf = function setConf(cnf) {\n  var keys = Object.keys(cnf);\n\n  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n    var key = _keys[_i];\n    conf[key] = cnf[key];\n  }\n};\n\nvar addVertices = function addVertices(vert, g, svgId, root, _doc, diagObj) {\n  var svg = !root ? select(\"[id=\\\"\".concat(svgId, \"\\\"]\")) : root.select(\"[id=\\\"\".concat(svgId, \"\\\"]\"));\n  var doc = !_doc ? document : _doc;\n  var keys = Object.keys(vert);\n  keys.forEach(function (id) {\n    var vertex = vert[id];\n    var classStr = \"default\";\n\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(\" \");\n    }\n\n    var styles = getStylesFromArray(vertex.styles);\n    var vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;\n    var vertexNode;\n\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      var node = {\n        label: vertexText.replace(/fa[blrs]?:fa-[\\w-]+/g, function (s) {\n          return \"<i class='\".concat(s.replace(\":\", \" \"), \"'></i>\");\n        })\n      };\n      vertexNode = addHtmlLabel(svg, node).node();\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      var svgLabel = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      svgLabel.setAttribute(\"style\", styles.labelStyle.replace(\"color:\", \"fill:\"));\n      var rows = vertexText.split(common.lineBreakRegex);\n\n      var _iterator = _createForOfIteratorHelper(rows),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var row = _step.value;\n          var tspan = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n          tspan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n          tspan.setAttribute(\"dy\", \"1em\");\n          tspan.setAttribute(\"x\", \"1\");\n          tspan.textContent = row;\n          svgLabel.appendChild(tspan);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      vertexNode = svgLabel;\n    }\n\n    var radious = 0;\n    var _shape = \"\";\n\n    switch (vertex.type) {\n      case \"round\":\n        radious = 5;\n        _shape = \"rect\";\n        break;\n\n      case \"square\":\n        _shape = \"rect\";\n        break;\n\n      case \"diamond\":\n        _shape = \"question\";\n        break;\n\n      case \"hexagon\":\n        _shape = \"hexagon\";\n        break;\n\n      case \"odd\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"lean_right\":\n        _shape = \"lean_right\";\n        break;\n\n      case \"lean_left\":\n        _shape = \"lean_left\";\n        break;\n\n      case \"trapezoid\":\n        _shape = \"trapezoid\";\n        break;\n\n      case \"inv_trapezoid\":\n        _shape = \"inv_trapezoid\";\n        break;\n\n      case \"odd_right\":\n        _shape = \"rect_left_inv_arrow\";\n        break;\n\n      case \"circle\":\n        _shape = \"circle\";\n        break;\n\n      case \"ellipse\":\n        _shape = \"ellipse\";\n        break;\n\n      case \"stadium\":\n        _shape = \"stadium\";\n        break;\n\n      case \"subroutine\":\n        _shape = \"subroutine\";\n        break;\n\n      case \"cylinder\":\n        _shape = \"cylinder\";\n        break;\n\n      case \"group\":\n        _shape = \"rect\";\n        break;\n\n      default:\n        _shape = \"rect\";\n    }\n\n    log.warn(\"Adding node\", vertex.id, vertex.domId);\n    g.setNode(diagObj.db.lookUpDomId(vertex.id), {\n      labelType: \"svg\",\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      label: vertexNode,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: diagObj.db.lookUpDomId(vertex.id)\n    });\n  });\n};\n\nvar addEdges = function addEdges(edges, g, diagObj) {\n  var cnt = 0;\n  var defaultStyle;\n  var defaultLabelStyle;\n\n  if (edges.defaultStyle !== void 0) {\n    var defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    cnt++;\n    var linkId = \"L-\" + edge.start + \"-\" + edge.end;\n    var linkNameStart = \"LS-\" + edge.start;\n    var linkNameEnd = \"LE-\" + edge.end;\n    var edgeData = {};\n\n    if (edge.type === \"arrow_open\") {\n      edgeData.arrowhead = \"none\";\n    } else {\n      edgeData.arrowhead = \"normal\";\n    }\n\n    var style = \"\";\n    var labelStyle = \"\";\n\n    if (edge.style !== void 0) {\n      var styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    } else {\n      switch (edge.stroke) {\n        case \"normal\":\n          style = \"fill:none\";\n\n          if (defaultStyle !== void 0) {\n            style = defaultStyle;\n          }\n\n          if (defaultLabelStyle !== void 0) {\n            labelStyle = defaultLabelStyle;\n          }\n\n          break;\n\n        case \"dotted\":\n          style = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n          break;\n\n        case \"thick\":\n          style = \" stroke-width: 3.5px;fill:none\";\n          break;\n      }\n    }\n\n    edgeData.style = style;\n    edgeData.labelStyle = labelStyle;\n\n    if (edge.interpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== void 0) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === void 0) {\n      if (edge.style !== void 0) {\n        edgeData.arrowheadStyle = \"fill: #333\";\n      }\n    } else {\n      edgeData.arrowheadStyle = \"fill: #333\";\n      edgeData.labelpos = \"c\";\n\n      if (evaluate(getConfig().flowchart.htmlLabels)) {\n        edgeData.labelType = \"html\";\n        edgeData.label = \"<span id=\\\"L-\".concat(linkId, \"\\\" class=\\\"edgeLabel L-\").concat(linkNameStart, \"' L-\").concat(linkNameEnd, \"\\\" style=\\\"\").concat(edgeData.labelStyle, \"\\\">\").concat(edge.text.replace(/fa[blrs]?:fa-[\\w-]+/g, function (s) {\n          return \"<i class='\".concat(s.replace(\":\", \" \"), \"'></i>\");\n        }), \"</span>\");\n      } else {\n        edgeData.labelType = \"text\";\n        edgeData.label = edge.text.replace(common.lineBreakRegex, \"\\n\");\n\n        if (edge.style === void 0) {\n          edgeData.style = edgeData.style || \"stroke: #333; stroke-width: 1.5px;fill:none\";\n        }\n\n        edgeData.labelStyle = edgeData.labelStyle.replace(\"color:\", \"fill:\");\n      }\n    }\n\n    edgeData.id = linkId;\n    edgeData.class = linkNameStart + \" \" + linkNameEnd;\n    edgeData.minlen = edge.length || 1;\n    g.setEdge(diagObj.db.lookUpDomId(edge.start), diagObj.db.lookUpDomId(edge.end), edgeData, cnt);\n  });\n};\n\nvar getClasses = function getClasses(text, diagObj) {\n  log.info(\"Extracting classes\");\n  diagObj.db.clear();\n\n  try {\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    log.error(e);\n    return {};\n  }\n};\n\nvar draw = function draw(text, id, _version, diagObj) {\n  log.info(\"Drawing flowchart\");\n  diagObj.db.clear();\n\n  var _getConfig = getConfig(),\n      securityLevel = _getConfig.securityLevel,\n      conf2 = _getConfig.flowchart;\n\n  var sandboxElement;\n\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = select(\"#i\" + id);\n  }\n\n  var root = securityLevel === \"sandbox\" ? select(sandboxElement.nodes()[0].contentDocument.body) : select(\"body\");\n  var doc = securityLevel === \"sandbox\" ? sandboxElement.nodes()[0].contentDocument : document;\n\n  try {\n    diagObj.parser.parse(text);\n  } catch (err) {\n    log.debug(\"Parsing failed\");\n  }\n\n  var dir = diagObj.db.getDirection();\n\n  if (dir === void 0) {\n    dir = \"TD\";\n  }\n\n  var nodeSpacing = conf2.nodeSpacing || 50;\n  var rankSpacing = conf2.rankSpacing || 50;\n  var g = new graphlib.Graph({\n    multigraph: true,\n    compound: true\n  }).setGraph({\n    rankdir: dir,\n    nodesep: nodeSpacing,\n    ranksep: rankSpacing,\n    marginx: 8,\n    marginy: 8\n  }).setDefaultEdgeLabel(function () {\n    return {};\n  });\n  var subG;\n  var subGraphs = diagObj.db.getSubGraphs();\n\n  for (var i2 = subGraphs.length - 1; i2 >= 0; i2--) {\n    subG = subGraphs[i2];\n    diagObj.db.addVertex(subG.id, subG.title, \"group\", void 0, subG.classes);\n  }\n\n  var vert = diagObj.db.getVertices();\n  log.warn(\"Get vertices\", vert);\n  var edges = diagObj.db.getEdges();\n  var i = 0;\n\n  for (i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    selectAll(\"cluster\").append(\"text\");\n\n    for (var j = 0; j < subG.nodes.length; j++) {\n      log.warn(\"Setting subgraph\", subG.nodes[j], diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));\n      g.setParent(diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));\n    }\n  }\n\n  addVertices(vert, g, id, root, doc, diagObj);\n  addEdges(edges, g, diagObj);\n  var render$1 = new render();\n  flowChartShapes.addToRender(render$1);\n\n  render$1.arrows().none = function normal(parent, id2, edge, type) {\n    var marker = parent.append(\"marker\").attr(\"id\", id2).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\");\n    var path = marker.append(\"path\").attr(\"d\", \"M 0 0 L 0 0 L 0 0 z\");\n    applyStyle(path, edge[type + \"Style\"]);\n  };\n\n  render$1.arrows().normal = function normal(parent, id2) {\n    var marker = parent.append(\"marker\").attr(\"id\", id2).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\");\n    marker.append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"class\", \"arrowheadPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  };\n\n  var svg = root.select(\"[id=\\\"\".concat(id, \"\\\"]\"));\n  var element = root.select(\"#\" + id + \" g\");\n  render$1(element, g);\n  element.selectAll(\"g.node\").attr(\"title\", function () {\n    return diagObj.db.getTooltip(this.id);\n  });\n  diagObj.db.indexNodes(\"subGraph\" + i);\n\n  for (i = 0; i < subGraphs.length; i++) {\n    subG = subGraphs[i];\n\n    if (subG.title !== \"undefined\") {\n      var clusterRects = doc.querySelectorAll(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(subG.id) + '\"] rect');\n      var clusterEl = doc.querySelectorAll(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(subG.id) + '\"]');\n      var xPos = clusterRects[0].x.baseVal.value;\n      var yPos = clusterRects[0].y.baseVal.value;\n      var _width = clusterRects[0].width.baseVal.value;\n      var cluster = select(clusterEl[0]);\n      var te = cluster.select(\".label\");\n      te.attr(\"transform\", \"translate(\".concat(xPos + _width / 2, \", \").concat(yPos + 14, \")\"));\n      te.attr(\"id\", id + \"Text\");\n\n      for (var _j = 0; _j < subG.classes.length; _j++) {\n        clusterEl[0].classList.add(subG.classes[_j]);\n      }\n    }\n  }\n\n  if (!conf2.htmlLabels) {\n    var labels = doc.querySelectorAll('[id=\"' + id + '\"] .edgeLabel .label');\n\n    var _iterator2 = _createForOfIteratorHelper(labels),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var label = _step2.value;\n        var dim = label.getBBox();\n        var rect = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        rect.setAttribute(\"rx\", 0);\n        rect.setAttribute(\"ry\", 0);\n        rect.setAttribute(\"width\", dim.width);\n        rect.setAttribute(\"height\", dim.height);\n        label.insertBefore(rect, label.firstChild);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  setupGraphViewbox(g, svg, conf2.diagramPadding, conf2.useMaxWidth);\n  var keys = Object.keys(vert);\n  keys.forEach(function (key) {\n    var vertex = vert[key];\n\n    if (vertex.link) {\n      var node = root.select(\"#\" + id + ' [id=\"' + diagObj.db.lookUpDomId(key) + '\"]');\n\n      if (node) {\n        var link = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"a\");\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"class\", vertex.classes.join(\" \"));\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"href\", vertex.link);\n        link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"rel\", \"noopener\");\n\n        if (securityLevel === \"sandbox\") {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", \"_top\");\n        } else if (vertex.linkTarget) {\n          link.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", vertex.linkTarget);\n        }\n\n        var linkNode = node.insert(function () {\n          return link;\n        }, \":first-child\");\n        var shape = node.select(\".label-container\");\n\n        if (shape) {\n          linkNode.append(function () {\n            return shape.node();\n          });\n        }\n\n        var _label = node.select(\".label\");\n\n        if (_label) {\n          linkNode.append(function () {\n            return _label.node();\n          });\n        }\n      }\n    }\n  });\n};\n\nvar flowRenderer = {\n  setConf: setConf,\n  addVertices: addVertices,\n  addEdges: addEdges,\n  getClasses: getClasses,\n  draw: draw\n};\nvar diagram = {\n  parser: parser,\n  db: flowDb,\n  renderer: flowRendererV2,\n  styles: flowStyles,\n  init: function init(cnf) {\n    if (!cnf.flowchart) {\n      cnf.flowchart = {};\n    }\n\n    cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;\n    flowRenderer.setConf(cnf.flowchart);\n    flowDb.clear();\n    flowDb.setGen(\"gen-1\");\n  }\n};\nexport { diagram };"],"names":["conf","flowRenderer","cnf","_i","_keys","Object","keys","length","key","diagram","parser","p","db","f","renderer","styles","init","flowchart","arrowMarkerAbsolute"],"sourceRoot":""}